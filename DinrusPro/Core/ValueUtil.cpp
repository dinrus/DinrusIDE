#include <DinrusPro/DinrusCore.h>

static Ткст sAsString(const Вектор<Значение>& v);

#define LTIMING(x) // RTIMING(x)

struct Реф::ValueRef : public РефМенеджер {
	virtual цел   дайТип()                            { return VALUE_V; }
	virtual Значение дайЗначение(кук укз)            { return *(Значение *) укз; }
	virtual бул  пусто_ли(кук укз)              { return пусто_ли(*(Значение *) укз); }
	virtual проц  устЗначение(ук укз, const Значение& v)  { *(Значение *) укз = v; }
	virtual проц  устПусто(ук укз)                   { *(Значение *) укз = Null; }
};

Реф::Реф(Ткст& s)  { укз = &s; m = &Сингл< СтдРеф<Ткст> >(); }
Реф::Реф(ШТкст& s) { укз = &s; m = &Сингл< СтдРеф<ШТкст> >(); }
Реф::Реф(цел& i)     { укз = &i; m = &Сингл< СтдРеф<цел> >(); }
Реф::Реф(дол& i)   { укз = &i; m = &Сингл< СтдРеф<дол> >(); }
Реф::Реф(дво& d)  { укз = &d; m = &Сингл< СтдРеф<дво> >(); }
Реф::Реф(бул& b)    { укз = &b; m = &Сингл< СтдРеф<бул> >(); }
Реф::Реф(Дата& d)    { укз = &d; m = &Сингл< СтдРеф<Дата> >(); }
Реф::Реф(Время& t)    { укз = &t; m = &Сингл< СтдРеф<Время> >(); }
Реф::Реф(Значение& v)   { укз = &v; m = &Сингл< ValueRef >(); }

// ----------------------------------

бул МассивЗнач::Данные::пусто_ли() const
{
	return данные.пустой();
}

проц МассивЗнач::Данные::сериализуй(Поток& s)
{
	s % данные;
}

проц МассивЗнач::Данные::вДжейсон(ДжейсонВВ& jio)
{
	вДжейсон(jio, данные);
}

проц МассивЗнач::Данные::вРяр(РярВВ& io)
{
	вРяр(io, данные);
}

т_хэш МассивЗнач::Данные::дайХэшЗнач() const
{
	КомбХэш w(данные.дайСчёт());
	for(цел i = 0; i < данные.дайСчёт(); i++)
		w.помести(данные[i].дайХэшЗнач());
	return w;
}

бул МассивЗнач::Данные::равен(const Значение::Проц *p)
{
	return ((Данные *)p)->данные == данные;
}

цел МассивЗнач::Данные::сравни(const Значение::Проц *p)
{
	return данные.сравни(((Данные *)p)->данные);
}

бул МассивЗнач::operator==(const МассивЗнач& v) const
{
	return v.данные->данные == данные->данные;
}

цел МассивЗнач::сравни(const МассивЗнач& b) const
{
	return данные->данные.сравни(b.данные->данные);
}

static Ткст sAsString(const Вектор<Значение>& v)
{
	Ткст s;
	s << "[";
	for(цел i = 0; i < v.дайСчёт(); i++) {
		if(i) s << ", ";
		s << v[i];
	}
	s << "]";
	return s;
}

Ткст МассивЗнач::Данные::какТкст() const
{
	return sAsString(данные);
}

Вектор<Значение> МассивЗнач::VoidData;

Вектор<Значение>& МассивЗнач::создай()
{
	данные = new Данные;
	return данные->данные;
}

Вектор<Значение>& МассивЗнач::клонируй() {
	if(данные->GetRefCount() != 1) {
		Данные *d = new Данные;
		d->данные = клонируй(данные->данные);
		данные->отпусти();
		данные = d;
	}
	return данные->данные;
}

проц МассивЗнач::иниц0()
{
	данные = &Сингл<ДанныеПусто>();
	данные->Retain();
}

МассивЗнач::МассивЗнач(const МассивЗнач& v) {
	данные = v.данные;
	данные->Retain();
}

МассивЗнач::МассивЗнач(МассивЗнач&& v) {
	данные = v.данные;
	v.иниц0();
}

МассивЗнач::МассивЗнач(Вектор<Значение>&& v)
{
	создай() = пикуй(v);
}

МассивЗнач::МассивЗнач(const Вектор<Значение>& v, цел deep)
{
	создай() = клонируй(v);
}

МассивЗнач::operator Значение() const {
	данные->Retain();
	return Значение(данные, VALUEARRAY_V);
}

МассивЗнач::МассивЗнач(const Значение& ист)
{
	if(!пусто_ли(ист)) {
		if(ист.является<МапЗнач>()) {
			МассивЗнач v = МапЗнач(ист);
			данные = v.данные;
			данные->Retain();
			return;
		}
		else {
			if(ист.дайТип() != VALUEARRAY_V)
				throw ОшибкаТипаЗначения(Ткст().кат() << "Invalid значение conversion: "
			                         << ист.дайИмяТипа() << " -> МассивЗнач",
			                         ист, VALUEARRAY_V);
			данные = (МассивЗнач::Данные *)ист.дайПроцУк();
		}
	}
	else
		данные = &Сингл<ДанныеПусто>();
	данные->Retain();
}

проц МассивЗнач::сериализуй(Поток& s) {
	if(s.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->сериализуй(s);
}

проц МассивЗнач::вДжейсон(ДжейсонВВ& jio)
{
	if(jio.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->вДжейсон(jio);
}

проц МассивЗнач::вРяр(РярВВ& xio)
{
	if(xio.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->вРяр(xio);
}

Ткст МассивЗнач::вТкст() const
{
	return sAsString(дай());
}

МассивЗнач::~МассивЗнач() {
	ПРОВЕРЬ(данные->GetRefCount() > 0);
	данные->отпусти();
}

МассивЗнач& МассивЗнач::operator=(const МассивЗнач& v) {
	v.данные->Retain();
	данные->отпусти();
	данные = v.данные;
	return *this;
}

проц МассивЗнач::устСчёт(цел n)
{
	клонируй().устСчёт(n);
}

проц МассивЗнач::устСчёт(цел n, const Значение& v)
{
	клонируй().устСчёт(n, v);
}

проц МассивЗнач::очисть() {
	клонируй().очисть();
}

проц МассивЗнач::добавь(const Значение& v) {
	клонируй().добавь(v);
}

проц МассивЗнач::уст(цел i, const Значение& v) {
#if !defined(_MSC_VER) || _MSC_VER > 1310
	ПРОВЕРЬ(i >= 0);
	клонируй().по(i) = v;
#else
	throw 0;
#endif
}

Значение& МассивЗнач::по(цел i)
{
	return клонируй().по(i);
}

проц МассивЗнач::удали(цел i, цел count)
{
	клонируй().удали(i, count);
}

проц МассивЗнач::удали(const Вектор<цел>& ii)
{
	клонируй().удали(ii);
}

проц МассивЗнач::вставь(цел i, const МассивЗнач& va)
{
	if(va.данные == данные) {
		МассивЗнач va2 = va;
		клонируй().вставь(i, va2.дай());
	}
	else
		клонируй().вставь(i, va.дай());
}

const Значение& МассивЗнач::дай(цел i) const {
	ПРОВЕРЬ(i >= 0 && i < дайСчёт());
	return данные->данные[i];
}

Значение МассивЗнач::дайИОчисть(цел i)
{
	ПРОВЕРЬ(i >= 0 && i < дайСчёт());
	Вектор<Значение>& x = клонируй();
	Значение v = x[i];
	x[i] = Значение();
	return v;
}

Вектор<Значение> МассивЗнач::подбери()
{
	Вектор<Значение>& x = клонируй();
	Вектор<Значение> r = пикуй(x);
	x.очисть();
	return r;
}

template<>
Ткст какТкст(const МассивЗнач& v) {
	return sAsString(v.дай());
}

бул МапЗнач::Данные::пусто_ли() const {
	return this == &Сингл<МапЗнач::ДанныеПусто>();
}

проц МапЗнач::Данные::сериализуй(Поток& s) {
	s % ключ % значение;
}

проц МапЗнач::Данные::вРяр(РярВВ& xio)
{
	вРяр(xio, ключ);
	вРяр(xio, значение);
}

проц МапЗнач::Данные::вДжейсон(ДжейсонВВ& jio)
{
	if(jio.сохраняется()) {
		МассивЗнач va;
		цел n = мин(значение.дайСчёт(), ключ.дайСчёт());
		for(цел i = 0; i < n; i++) {
			МапЗнач m;
			m.добавь("ключ", сохраниКакЗначДжейсон(ключ[i]));
			m.добавь("значение", сохраниКакЗначДжейсон(значение[i]));
			va.добавь(m);
		}
		jio.уст(va);
	}
	else {
		Значение va = jio.дай();
		ключ.очисть();
		значение.очисть();
		for(цел i = 0; i < va.дайСчёт(); i++) {
			Значение k, v;
			загрузиИзЗначДжейсон(k, va[i]["ключ"]);
			загрузиИзЗначДжейсон(v, va[i]["значение"]);
			ключ.добавь(k);
			значение.добавь(v);
		}
	}
}

т_хэш МапЗнач::Данные::дайХэшЗнач() const {
	КомбХэш w(ключ.дайСчёт());
	for(цел i = 0; i < ключ.дайСчёт(); i++)
		w.помести(ключ[i].дайХэшЗнач());
	w.помести(значение.дайХэшЗнач());
	return w;
}

static бул sIsEqual(const Индекс<Значение>& a, const Индекс<Значение>& b)
{
	if(&a == &b) return true;
	if(a.дайСчёт() != b.дайСчёт()) return false;
	for(цел i = 0; i < a.дайСчёт(); i++)
		if(a[i] != b[i]) return false;
	return true;
}

бул МапЗнач::Данные::равен(const Значение::Проц *p)
{
	return sIsEqual(((Данные *)p)->ключ, ключ) && ((Данные *)p)->значение == значение;
}

бул МапЗнач::operator==(const МапЗнач& v) const
{
	return sIsEqual(данные->ключ, v.данные->ключ) && данные->значение == v.данные->значение;
}

цел  МапЗнач::Данные::сравни(const Значение::Проц *p)
{
	Данные *b = (Данные *)p;
	цел n = мин(ключ.дайСчёт(), b->ключ.дайСчёт());
	for(цел i = 0; i < n; i++) {
		цел q = сравниЗнак(ключ[i], b->ключ[i]);
		if(q)
			return q;
		q = сравниЗнак(значение[i], b->значение[i]);
		if(q)
			return q;
	}
	return сравниЗнак(ключ.дайСчёт(), b->ключ.дайСчёт());
}

цел МапЗнач::сравни(const МапЗнач& b) const
{
	return данные->сравни((Значение::Проц *)b.данные);
}

бул МапЗнач::одинаково(const МапЗнач& b) const
{
	for(цел pass = 0; pass < 2; pass++) {
		const МапЗнач& m = pass ? *this : b;
		const МапЗнач& n = pass ? b : *this;
		for(цел i = 0; i < m.дайСчёт(); i++)
			if(!n[m.дайКлюч(i)].одинаково(m.дайЗначение(i)))
				return false;
	}
	return true;
}

Ткст МапЗнач::Данные::какТкст() const
{
	Ткст s;
	s << "{ ";
	for(цел i = 0; i < ключ.дайСчёт(); i++) {
		if(i) s << ", ";
		s << ключ[i] << ": " << значение[i];
	}
	s << " }";
	return s;
}

МапЗнач::Данные& МапЗнач::создай()
{
	данные = new Данные;
	return *данные;
}

проц МапЗнач::клонируй(Данные *&укз)
{
	Данные *d = new Данные;
	d->ключ = клонируй(укз->ключ);
	d->значение = укз->значение;
	укз->отпусти();
	укз = d;
}

проц МапЗнач::иниц0()
{
	данные = &Сингл<ДанныеПусто>();
	данные->Retain();
}

МапЗнач::МапЗнач(const МапЗнач& v)
{
	данные = v.данные;
	данные->Retain();
}

МапЗнач::МапЗнач(Индекс<Значение>&& k, Вектор<Значение>&& v)
{
	Данные& d = создай();
	d.ключ = пикуй(k);
	d.значение = МассивЗнач(пикуй(v));
}

МапЗнач::МапЗнач(ВекторМап<Значение, Значение>&& m)
{
	Данные& d = создай();
	d.ключ = m.подбериКлючи();
	d.значение = МассивЗнач(m.подбериЗначения());
}

МапЗнач::МапЗнач(const Индекс<Значение>& k, const Вектор<Значение>& v, цел deep)
{
	Данные& d = создай();
	d.ключ = клонируй(k);
	d.значение = МассивЗнач(v, 0);
}

МапЗнач::МапЗнач(const ВекторМап<Значение, Значение>& m, цел deep)
{
	Данные& d = создай();
	d.ключ = клонируй(m.дайКлючи());
	d.значение = МассивЗнач(m.дайЗначения(), 0);
}

ВекторМап<Значение, Значение> МапЗнач::подбери()
{
	Данные& d = разшарь();
	ВекторМап<Значение, Значение> m(d.ключ.подбериКлючи(), d.значение.подбери());
	d.ключ.очисть();
	return m;
}

МапЗнач::operator Значение() const {
	данные->Retain();
	return Значение(данные, VALUEMAP_V);
}

проц МапЗнач::изМассива(const МассивЗнач& va)
{
	иниц0();
	for(цел i = 0; i < va.дайСчёт(); i++)
		добавь(i, va[i]);
}

МапЗнач::МапЗнач(const Значение& ист)
{
	if(!пусто_ли(ист)) {
		if(ист.является<МассивЗнач>()) {
			изМассива(ист);
			return;
		}
		else {
			if(ист.дайТип() != VALUEMAP_V)
				throw ОшибкаТипаЗначения(Ткст().кат() << "Invalid значение conversion: "
			                         << ист.дайИмяТипа() << " -> МапЗнач",
			                         ист, VALUEMAP_V);
			данные = (МапЗнач::Данные *)ист.дайПроцУк();
		}
	}
	else
		данные = &Сингл<ДанныеПусто>();
	данные->Retain();
}

проц МапЗнач::сериализуй(Поток& s) {
	if(s.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->сериализуй(s);
}

проц МапЗнач::вДжейсон(ДжейсонВВ& jio)
{
	if(jio.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->вДжейсон(jio);
}

проц МапЗнач::вРяр(РярВВ& xio)
{
	if(xio.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->вРяр(xio);
}

МапЗнач::~МапЗнач() {
	ПРОВЕРЬ(данные->GetRefCount() > 0);
	данные->отпусти();
}

МапЗнач& МапЗнач::operator=(const МапЗнач& v) {
	v.данные->Retain();
	данные->отпусти();
	данные = v.данные;
	return *this;
}

проц МапЗнач::очисть() {
	данные->отпусти();
	иниц0();
}

проц МапЗнач::уст(const Значение& ключ, const Значение& значение)
{
	Данные& d = разшарь();
	цел i = d.ключ.найди(ключ);
	if(i >= 0)
		d.значение.уст(i, значение);
	else {
		d.ключ.добавь(ключ);
		d.значение.добавь(значение);
	}
}

проц МапЗнач::устПо(цел i, const Значение& v) {
	разшарь().значение.уст(i, v);
}

проц МапЗнач::устКлюч(цел i, const Значение& k) {
	разшарь().ключ.уст(i, k);
}

цел МапЗнач::удалиКлюч(const Значение& ключ)
{
	Данные& d = разшарь();
	Вектор<цел> rk;
	цел q = d.ключ.найди(ключ);
	while(q >= 0) {
		rk.добавь(q);
		q = d.ключ.найдиСледщ(q);
	}
	if(rk.дайСчёт()) {
		сортируй(rk);
		d.ключ.удали(rk);
		d.значение.удали(rk);
	}
	return rk.дайСчёт();
}

проц МапЗнач::удали(цел i)
{
	Данные& d = разшарь();
	d.ключ.удали(i);
	d.значение.удали(i);
}

Значение МапЗнач::дайИОчисть(const Значение& ключ)
{
	Данные& d = разшарь();
	цел q = d.ключ.найди(ключ);
	return q < 0 ? значОш() : d.значение.дайИОчисть(q);
}

// ----------------------------------

бул StdValuePairOrder::operator()(const Значение& k1, const Значение& v1, const Значение& k2, const Значение& v2) const
{
	цел q = сравниСтдЗнач(k1, k2, язык);
	if(q) return q < 0;
	return сравниСтдЗнач(v1, v2, язык);
}

бул FnValuePairOrder::operator()(const Значение& keya, const Значение& valuea, const Значение& keyb, const Значение& valueb) const
{
	return (*фн)(keya, valuea, keyb, valueb) < 0;
}

цел сравниТксты(const Значение& a, const Значение& b, const ИнфОЯз& f)
{
	return f.сравни(ШТкст(a), ШТкст(b));
}

проц Комплекс::вРяр(РярВВ& xio)
{
	дво r, i;
	r = real(); i = imag();
	xio.Атр("real", r).Атр("imag", i);
	*this = C(r, i);
}

проц Комплекс::вДжейсон(ДжейсонВВ& jio)
{
	дво r, i;
	r = real(); i = imag();
	jio("real", r)("imag", i);
	*this = C(r, i);
}

проц Комплекс::сериализуй(Поток& s)
{
	дво r, i;
	r = real(); i = imag();
	s % r % i;
	*this = C(r, i);
}

template <class T>
static проц sReg(кткст0 имя)
{
	if(вмещаетсяВЗначСво<T>())
		Значение::SvoRegister<T>(имя);
	else
		Значение::регистрируй<T>(имя);
}

ИНИЦБЛОК
{
	sReg<Точка>("Точка");
	sReg<Точка64>("Точка64");
	sReg<ТочкаПЗ>("ТочкаПЗ");
	sReg<Размер>("Размер");
	sReg<Размер64>("Размер64");
	sReg<РазмерПЗ>("РазмерПЗ");
	Значение::регистрируй<Прям>("Прям");
	Значение::регистрируй<Прям64>("Прям64");
	Значение::регистрируй<ПрямПЗ>("ПрямПЗ");
}
