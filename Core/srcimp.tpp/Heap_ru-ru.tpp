topic "Реализация кучи";
[i448;a25;kKO9;*@(64)2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,2#27521748481378242620020725143825:desc]
[a83;*R6 $$3,0#31310162474203024125188417583966:caption]
[l288;i1121;b17;O9;~~~.1408;2 $$4,0#10431211400427159095818037425705:param]
[i448;a25;kKO9;*@(64)2 $$5,0#37138531426314131252341829483370:item]
[b108;*+117 $$6,6#14700283458701402223321329925657:header]
[l416;2 $$7,7#55548704457842300043401641954952:nested`-desc]
[l288;i448;a25;kO9;*2 $$8,8#64691275497409617375831514634295:nested`-class]
[b33;2 $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[s3; Реализация кучи&]
[s0; Куча U`+`+ разделяется на 4 категории 
по размеру блока: small, medium, huge и system 
`- малая, средняя, большая и системная.&]
[s0; &]
[s6; Малые (small) блоки&]
[s0; Блоки <`= 992 байтов. Согласно нашему 
исследованию, блоки <`= 992 обычно представляют
 большинство блоков, используемых 
в типичных приложениях C`+`+/U`+`+ (>98% 
всех блоков).&]
[s0; Малые блоки размещаются в памяти 
на страницах в 4 КБ, т.е. являются `"4 
КБ aligned`" (`"разлинованными по 4 КБ`").&]
[s0; Для малых блоков существует 18 возможных 
размеров блока (32, 64, 96, 128, 160, 192, 224, 
256, 288, 320, 352, 384, 448, 576, 672, 800, 992). Размеры 
более больших блоков разработана 
так, чтобы округлялись до 32 байт и 
использовали большую часть памяти 
на странице (4096 `- 32 `= 4064) (смотрите 
ниже). Например, 4064 / 7 `= 580, что понижается 
при настройке до 576, тем самым теряя 
только 4064 `- 576 `* 7 `= 32 байта на страницу 
в 4 КБ.&]
[s0; Каждая страница в 4 КБ предназначается 
для размера одного блока. Следовательно, 
не нужно хранить никакой дополнительной 
информации, касающейся блока; вместо 
этого информация обо всём блоке хранится 
в 32`-байтном заголовочнике, в начале 
4 КБной страницы. Этот заголовочник 
хранит указатель на список свободных 
блоков страницы, double`-link указатели 
для блока, так, чтобы он мог сохраняться 
в структурах аллокатора (разместителя), 
общее число блоков на странице в 4 
КБ и число свободных блоков на ней.&]
[s0; При том, что у блоков нет индивидуальных 
заголовочников, критическая деталь 
реализации заключается в том, как 
процедура FreeMemory детектирует (находит) 
малые блоки. Это решается помещением 
данной информации прямо в указатель 
на кучу: у малых блоков всегда есть 
bit 5 of address one, в то время как у других 
категорий блоков он равен нулю. Другими 
словами, малые блоки являются `"32 bytes 
misaligned`", а другие категории `- `"32 bytes 
aligned`".&]
[s0; Как только в MemoryFree обнаруживается 
малый блок, нужная справочная информация 
ищется в начале 4`-КБных блоков.&]
[s0; Аллокатор отслеживает 4`-КБные страницы, 
используемые целиком (без свободных 
блоков), частично использованные 
или пустые. Пустые страницы в любое 
время могут преобразовываться в блок 
другого размера.&]
[s0; Также аллокатор использует кэш малых 
блоков в качестве дополнительной 
оптимизации. В этом кэше, до около 
3.5 КБ малых блоков на размер малого 
блока хранится свободно, без вызова 
более сложной процедуры вымещения 
(деаллокации).&]
[s6; Средние (medium) блоки &]
[s0; Блоки >256 и < 65504 байтов. Для этих блоков 
используется `"approximate best`-fit allocator`" 
(`"приблизительный разместитель наилучшего 
соответствия`"). Память организована 
в виде страниц по 64 КБ. У каждого блока 
аллокатора есть `"заголовочник`" (header) 
с его размером и размером предыдущего 
блока, флагом free и указателем на кучу 
(the Heap).&]
[s0; Аллокатор хранит массив списков 
свободных блоков конкретных размеров. 
Распределение размера в основном 
экспоненциально, блоки, меньшие 2048, 
округляются до 32 байтов, между 2048 
и около 35000 округление экспоненциально 
наращивается до 2048, а затем останавливается 
на этом значение. У каждого такого 
размера есть индекс в массиве свободных 
блоков.&]
[s0; При размещении (аллокации), по размеру 
подбирается индекс и производится 
поиск по массиву, начиная с этого 
индекса, находящий наименьший свободный 
блок (best`-fit, `"наилучшего соответствия`"), 
больший, чем требуемый размер. Более 
большие блоки делятся, а остальные 
помещаются в список свободных блоков.&]
[s0; При освобождении, аллокатор `"маржует`" 
(merges) освобождённые блоки с предыдущим 
или следующим блоком, если он есть, 
и меняет значения в списке свободных 
блоков.&]
[s0; Заметьте, что заголовочник`-мастер 
(master header) из  64`-КБных блоков и все операции 
разработаны так, что итоговые указатели 
НЕ являются `"32 bytes aligned`" (смотрите 
описание малых блоков).&]
[s6; Большие (huge) блоки&]
[s0; Существует разделяемая (между потоками`-`"ни
тями`" (threads)) подкуча для блоков, меньших 
16 МБ, с единицей размещения в 4 КБ. 
Блоки, большие 65504 байтов и меньшие 
16 МБ, размещаются прямо из неё. Единица 
размещения равна 4 КБ. Малые и средние 
страницы также размещаются из этой 
подкучи.&]
[s0; Эта категория решает две проблемы: 
Размешение о освобождение системных 
блоков на редкость затратная (ресурсоёмкая) 
операция, поэтому данная подкуча 
оптимизирует ситуацию. Она также 
позвволяет преобразовывать память 
между малыми, в 4 КБ, и средними, в 64 
КБ, страницами.&]
[s6; Системные блоки&]
[s0; Блоки, большие 16 МБ, размещаются прямо 
из системы.&]
[s0; &]
[s6; Многопоточность (Multithreading)&]
[s0; Каждый поток имеет свою собственную 
кучу с малыми и средними блоками (реализован
ную посредством TLS, т.е. по`-русски 
НЛХ `= `"НитеЛокальное Хранилище`", 
по другому выражаясь, `- `"частное хранилище 
данного потока`"), а также имеется 
вспомогательная `- `'aux`' `- куча, которая, 
главным образом, используется для 
отслеживания полностью свободных 
страниц в 4 КБ или отрезков (`"чанков`") 
в 64 КБ.&]
[s0; Большинство размещений малых и средних 
блоков происходит без запирания (lockless). 
Единый стопор (mutex) для всего разместителя 
(allocator) запирается в следующих, относительно 
редких, ситуациях:&]
[s0;i150;O0; При освобождении блока, размещённого 
в другом потоке (имеющего иную кучу).Такие 
блоки сначала буферируются, если 
их общий размер не более 2000 байтов, 
а затем запирается стопор и все блоки 
поставляются в списки удалённого 
освобождения (remote`_free) соответствующих 
куч.&]
[s0;i150;O0; При размещении малого блока, 
когда нет доступного блока на частично 
используемых страницах, и недоступна 
`"резервная`" `-`'reserve`' `- пустая страница 
(любого размерного класса) `- в таком 
случае, запирается стопор и разруливается 
ситуация, либо путём получения свободной 
страницы из глобального хранилища, 
путём переятия `"сиротливой`" частично 
используемой страницы у вспомогательной 
кучи, либо,`- если всё прочее не сработает,`- 
путём получения страницы у системы. 
Как часть этого процесса, проверяется 
указатель на remote`_list (без блокировки`-запиран
ия) ,а, если он не равен null, то стопор 
запирается и обрабатываются страницы, 
освобождаемые дистанционно.&]
[s0;i150;O0; При освобождении малого блока, 
приводящем к полностью свободной 
странице, и когда куча уже имеет резервную 
пустую страницу для данного размерного 
класса. В таком случае, резервная 
страница помещается в глобальный 
список пустых страниц, а новая свободная 
страница используется в качестве 
новой резервной (потому что, по всей 
вероятности, новая страница в кэше 
наиболее `'горячая`').&]
[s0;i150;O0; При освобождении большого блока, 
размещённого в другом потоке. В этом 
случае, стопор запирается и блок помещается 
в кучу large`_remote`_free соответствующего 
потока.&]
[s0;i150;O0; При размещении большого блока 
и при отсутствии доступного. В этом 
случае, запирается стопор и соответствующим
 образом освобождаются блоки large`_remote`_free, 
а затем следует очередная попытка 
аллокации.&]
[s0;i150;O0; При размещении из большой или 
системной кучи, стопор (mutex) всегда 
запирается.&]
[s6; Специфичные фишки&]
[s0; Помимо стандартного обычного интерфейса, 
типа free/malloc, разместитель U`+`+ предоставляет 
некоторые специфичные `"фичи`":&]
[s0; MemoryAllocSz меняет размерный параметр 
так, чтобы он действительно отражал 
реально размещённое свободное пространство
 памяти.&]
[s0; MemoryAlloc32 и MemoryFree32  `- это версии, оптимизирован
ные на размещение ровно 32 байтов, 
представляющих собой важный размер 
для типа U`+`+ String `- зная точный размер, 
разместитель может пропускать несколько 
ветвлений (branches).&]
[s0; Поскольку минимальный размер возвращаемого
 блока обычно равен 32 байтам, разместитель 
U`+`+ может эффективно размещать даже 
меньшего размера блоки, используя 
интерфейс TinyAlloc / TinyFree: всего то нужно, 
чтобы TinyFree получил размер блока, затребованн
ого TinyAlloc, в качестве аргумента. Заметьте, 
что эти блоки всё ещё малые, то есть 
может находиться 508 блоков длиной 
в 8 байтов на странице в 4 КБ.&]
[s0; ]]