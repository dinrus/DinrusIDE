topic "Функции Кучи";
[i448;a25;kKO9;2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,2#27521748481378242620020725143825:desc]
[0 $$3,0#96390100711032703541132217272105:end]
[H6;0 $$4,0#05600065144404261032431302351956:begin]
[i448;a25;kKO9;2 $$5,0#37138531426314131252341829483370:item]
[l288;a4;*@5;1 $$6,6#70004532496200323422659154056402:requirement]
[l288;i1121;b17;O9;~~~.1408;2 $$7,0#10431211400427159095818037425705:param]
[i448;b42;O9;2 $$8,8#61672508125594000341940100500538:tparam]
[b42;2 $$9,9#13035079074754324216151401829390:normal]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_} 
[ {{10000@(113.42.0) [s0;%RU-RU [*@7;4 Куча (Heap)]]}}&]
[s3; &]
[s0; В U`+`+ есть свой высокопроизводительный 
аллокатор, настроенный под использование 
с U`+`+. Глобальные операторы new/delete, 
как правило, перегружаются под использовани
е этого аллокатора, если это возможно, 
или если не юыл определён макрос flagUSEMALLOC 
(напр., конфигурация главного пакета 
содержит USEMALLOC).&]
[s0; &]
[ {{10000F(128)G(128)@1 [s0;%RU-RU [* Basic allocation functions]]}}&]
[s3; &]
[s5;:Upp`:`:MemoryAllocPermanent`(size`_t`): [@(0.0.255) void]_`*[* MemoryAllocPermanent](
[_^size`_t^ size`_t]_[*@3 size])&]
[s2;%RU-RU Размещает блок памяти в [%-*@3 size] 
байтов. Этот указатель перманентен 
и не может быть освобождён, также 
он игнорируется при проверке утечек 
памяти.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:MemoryAllocSz`(size`_t`&`): [@(0.0.255) void]_`*[* MemoryAllocSz]([_^size`_t^ s
ize`_t][@(0.0.255) `&]_[*@3 size])&]
[s2;%RU-RU Размещает блок памяти, как минимум, 
в [%-*@3 size] байтов. [%-*@3 size] устанавливается 
в реальное число байтов в блоке, которое 
может быть использовано приложением. 
Гарантированная разлиновка (alignment) 
указывается в константе [* UPP`_HEAP`_ALIGNMENT] 
(на данный момент 16). Минимальный реальный 
размер возвращаемого блока в режиме 
выпуска (release) равен [* UPP`_HEAP`_MINBLOCK] (на 
данный момент 32).&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:MemoryAlloc`(size`_t`): [@(0.0.255) void]_`*[* MemoryAlloc]([_^size`_t^ size`_t
]_[*@3 size])&]
[s2;%RU-RU Размещает блок памяти, как минимум, 
в [%-*@3 size] байтов.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:MemoryFree`(void`*`): [@(0.0.255) void]_[* MemoryFree]([@(0.0.255) void]_`*[*@3 p
tr])&]
[s2;%RU-RU Освобождает блок, ранее размещённый 
в MemoryAllocSz или MemoryAlloc.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:MemoryAlloc32`(`): [@(0.0.255) void]_`*[* MemoryAlloc32]()&]
[s2;%RU-RU Размещает блок памяти ровно в 
32 байта. Функциональность такая же, 
как у MemoryAlloc(32), но слегка быстрее.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:MemoryFree32`(void`*`): [@(0.0.255) void]_[* MemoryFree32]([@(0.0.255) void]_`*
[*@3 ptr])&]
[s2;%RU-RU Освобождает блок памяти, ранее 
размещённый с MemoryAlloc32. Функциональность 
такая же, как у MemoryFree([%-*@3 ptr]), но слегка 
быстрее.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:MemoryTryRealloc`(void`*`,size`_t`&`): [@(0.0.255) bool]_[* MemoryTryRealloc](
[@(0.0.255) void]_`*[*@3 ptr], [_^size`_t^ size`_t][@(0.0.255) `&]_[*@3 newsize])&]
[s2;%RU-RU Пытается изменить размер блока 
по указателюt [%-*@3 ptr] в чему`-то, близкому 
к [%-*@3 newsize]. Реальное значение возвращается 
в [%-*@3 newsize]. Возвращает true при успехе.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:TinyAlloc`(int`): [@(0.0.255) void]_`*[* TinyAlloc]([@(0.0.255) int]_[*@3 size])&]
[s2;%RU-RU Размещает блок в [%-*@3 size] байтов. 
Это позволяет размещать меньшие блоки 
реального размера (как правило, минимальный 
размер возвращаемого блока равен 
32 байта), но требует, чтобы блок высвобождалс
я посредством TinyFree.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:TinyFree`(int`,void`*`): [@(0.0.255) void]_[* TinyFree]([@(0.0.255) int]_[*@3 siz
e], [@(0.0.255) void]_`*[*@3 ptr])&]
[s2;%RU-RU Высвобождает блок, размещённый 
посредством TinyAlloc, [%-*@3 size] должен быть 
таким же, как при аллокации.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:tiny`_new`(Args`.`.`.args`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T],
 [@(0.0.255) class...]_[*@4 Args]>_[*@4 T]_`*[* tiny`_new]([*@4 Args][@(0.0.255) ...]_args)&]
[s2;%RU-RU Размещает единичный объект посредством 
TinyAlloc и инициализирует его (with placement 
new).&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:tiny`_delete`(T`*`): [@(0.0.255) template]_<[@(0.0.255) class]_[*@4 T]>_[@(0.0.255) v
oid]_[* tiny`_delete]([*@4 T]_`*[*@3 ptr])&]
[s2;%RU-RU Удаляет объект, размещённый с 
помощью tiny`_new.&]
[s0;%RU-RU &]
[ {{10000F(128)G(128)@1 [s0;%RU-RU [* Heap diagnostics]]}}&]
[s3;%RU-RU &]
[s5;:Upp`:`:GetMemoryBlockSize`(void`*`): [_^size`_t^ size`_t]_[* GetMemoryBlockSize]([@(0.0.255) v
oid]_`*[*@3 ptr])&]
[s2;%RU-RU Возвращает размер блока в байтах.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:MemoryCheck`(`): [@(0.0.255) void]_[* MemoryCheck]()&]
[s2;%RU-RU Проверяет кучу на наличие ошибок 
(вызванных, например, переполнением 
буфера).&]
[s3; &]
[s4; &]
[s5;:Upp`:`:MemoryDumpLarge`(`): [@(0.0.255) void]_[* MemoryDumpLarge]()&]
[s2;%RU-RU Делает дамп списка больших размещений 
(large) (1`-64KB) в стандартный лог.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:MemoryDumpHuge`(`): [@(0.0.255) void]_[* MemoryDumpHuge]()&]
[s2;%RU-RU Делает дамп списка  ещё больших 
размещений (huge) (как правило, 64KB `- 16MB) 
в стандартный лог.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:MemoryUsedKb`(`): [@(0.0.255) int]_[* MemoryUsedKb]()&]
[s2;%RU-RU Возвращает текущую используемую 
память.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:MemoryUsedKbMax`(`): [@(0.0.255) int]_[* MemoryUsedKbMax]()&]
[s2;%RU-RU Возвращает пиковое использование 
памяти.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:MemoryLimitKb`(int`): [@(0.0.255) void]_[* MemoryLimitKb]([@(0.0.255) int]_[*@3 k
b])&]
[s2;%RU-RU Ота отладочная / диагностическая 
функция ограничивает использование 
памяти до [%-*@3 kb] килобайтов. Если приложение 
размещает больше, она останавливает 
его с ошибкой.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:MemoryGetCurrentSerial`(`): [_^Upp`:`:dword^ dword]_[* MemoryGetCurrentSerial
]()&]
[s2;%RU-RU В отладочном режиме, возвращает 
серийный номер следующего размещаемого 
блока. TЭтот номер, в итоге, попадает 
в список в логе, в случае наличия утечек 
памяти.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:MemoryIgnoreNonMainLeaks`(`): [@(0.0.255) void]_[* MemoryIgnoreNonMainLeaks](
)&]
[s2;%RU-RU Заставляет детектор утечек памяти 
игнорировать утечки в глобальных 
конструкторах.&]
[s3;%RU-RU &]
[s4; &]
[s5;:Upp`:`:MemoryIgnoreNonUppThreadsLeaks`(`): [@(0.0.255) void]_[* MemoryIgnoreNonUppTh
readsLeaks]()&]
[s2;%RU-RU Заставляет детектор утечек памяти 
игнорировать утечки, созданные потоками, 
которые не запущены из класса U`+`+ 
Thread.&]
[s3; &]
[s4; &]
[s5;:Upp`:`:MemoryIgnoreLeaksBegin`(`): [@(0.0.255) void]_[* MemoryIgnoreLeaksBegin]()&]
[s2;%RU-RU Заставляет детектор утечек памяти 
игнорировать утечки в блоках, размещённых 
до вызова [%-* MemoryIgnoreLeaksEnd]. Вызов может 
быть гнездовым (be nested). Это особенно 
полезно при работе со сторонним кодом 
(`"3rd party code`"), который может, например, 
создать статические утечки (память 
размещается только раз, но библиотека 
не вымещает её при выходе (on exit)).&]
[s3; &]
[s4; &]
[s5;:Upp`:`:MemoryIgnoreLeaksEnd`(`): [@(0.0.255) void]_[* MemoryIgnoreLeaksEnd]()&]
[s2;%RU-RU Завершает подавление, начатое 
MemoryIgnoreLeaksBegin.&]
[s3;%RU-RU &]
[s4; &]
[s1;:Upp`:`:MemoryIgnoreLeaksBlock`:`:struct: [@(0.0.255) struct]_[* MemoryIgnoreLeaksBlo
ck]&]
[s2;%RU-RU Этот вспомогательный класс вызывает 
в конструкторе [%-* MemoryIgnoreLeaksBegin] и [%-* MemoryIgnoreLeaksEnd
], другими словами, подавляет утечки 
до конца блока.&]
[s3;%RU-RU &]
[ {{10000F(128)G(128)@1 [s0;%RU-RU [* Тюнинг кучи]]}}&]
[s0;%RU-RU &]
[s0;%RU-RU Тюнинг кучи предоставляется классом 
MemoryOptions. Конструктор этого класса 
устанавливает дефолтные значения 
конкретных параметров, деструктор 
применяет их к подсистеме кучи.]]