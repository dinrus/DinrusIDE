#include <DinrusPro/DinrusCore.h>

//#BLITZ_APPROVE

ИНИЦБЛОК {
	Значение::регистрируй<Ууид>("Ууид");
}

проц Ууид::сериализуй(Поток& s) {
	цел версия = 0;
	s / версия % v[0] % v[1];
}

проц Ууид::вДжейсон(ДжейсонВВ& jio)
{
	Ткст h;
	if(jio.сохраняется()) {
		h = фмт(*this);
		jio.уст(h);
	}
	else
		*this = сканируйУуид((Ткст)jio.дай());
}

проц Ууид::нов()
{
	do
		случ64(v, 2);
	while(экзПусто_ли());
}

Ткст фмт(const Ууид& ид) {
	return спринтф("%08X%08X%08X%08X", МЛБЦЕЛ(ид.v[0]), СДЕЛАЙБЦЕЛ(ид.v[0]), МЛБЦЕЛ(ид.v[1]), СДЕЛАЙБЦЕЛ(ид.v[1]));
}

Ткст фмтСТире(const Ууид& ид) {
	return спринтф("%08X-%04X-%04X-%04X-%04X%08X", МЛБЦЕЛ(ид.v[0]),
	               HIWORD(СДЕЛАЙБЦЕЛ(ид.v[0])), LOWORD(СДЕЛАЙБЦЕЛ(ид.v[0])),
	               HIWORD(МЛБЦЕЛ(ид.v[1])), LOWORD(МЛБЦЕЛ(ид.v[1])),
	               СДЕЛАЙБЦЕЛ(ид.v[1]));
}

бцел scanX(кткст0 s)
{
    бцел r = 0;
    for(цел i = 0; i < 8; i++) {
        r = (r << 4) | (*s >= '0' && *s <= '9' ?      *s - '0' :
                        *s >= 'A' && *s <= 'F' ? 10 + *s - 'A' :
                        *s >= 'a' && *s <= 'f' ? 10 + *s - 'a' : 0);
        s++;
    }
    return r;
}

Ууид сканируйУуид(кткст0 s)
{
	Ууид ид;
	Ткст xu;
	while(*s) {
		if(IsXDigit(*s))
			xu.кат(*s);
		s++;
	}
	if(xu.дайСчёт() < 32)
		return Null;
	ид.v[0] = СДЕЛАЙБДОЛ(scanX(~xu), scanX(~xu + 8));
	ид.v[1] = СДЕЛАЙБДОЛ(scanX(~xu + 16), scanX(~xu + 24));
	return ид;
}

проц Ууид::вРяр(РярВВ& xio)
{
	Ткст h;
	if(xio.сохраняется())
		h = фмт(*this);
	xio.Атр("значение", h);
	if(xio.грузится())
		*this = сканируйУуид(h);
}

Ткст Ууид::вТкст() const
{
	return фмт(*this);
}

Ткст Ууид::ToStringWithDashes() const
{
	return фмтСТире(*this);
}

Ткст дамп(const Ууид& ид) {
	return "UUID: " + фмт(ид);
}

struct УуидValueGenClass : ГенЗнач
{
	virtual Значение дай() {
		return фмт(Ууид::создай());
	}
};

ГенЗнач& генЗначУуид()
{
	return Сингл<УуидValueGenClass>();
}
