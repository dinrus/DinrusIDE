#include <DinrusPro/DinrusCore.h>
#include <Core/Core.h>

бул  пустой(const Ткст& s)      { return s.пустой(); }

std::string вСтдстр(const Ткст& s)              { return std::string(s.старт(), s.стоп()); }

проц LOGNOP__() {}

проц устпам8(ук укз, ббайт данные, т_мера счёт)
{
	Upp::memset8(укз, данные, счёт);
}

проц устпам16(ук укз, бкрат данные, т_мера счёт)
{
	Upp::memset16(укз, данные, счёт);
}

проц устпам32(ук укз, бцел данные, т_мера счёт)
{
	Upp::memset32(укз, данные, счёт);
}

проц устпам64(ук укз, бдол данные, т_мера счёт)
{
	Upp::memset64(укз, данные, счёт);
}

проц устпам128(ук укз, Upp::m128 данные, т_мера счёт)
{
	Upp::memset128(укз, данные, счёт);
}

/////////////////////////////////////////////

проц копирпам8(ук p, кук q, т_мера счёт)
{
	Upp::memcpy8(p, q, счёт);
}

проц копирпам16(ук p, кук q, т_мера счёт)
{
	Upp::memcpy16(p, q, счёт);
}

проц копирпам32(ук p, кук q, т_мера счёт)
{
	Upp::memcpy32(p, q, счёт);
}

проц копирпам64(ук p, кук q, т_мера счёт)
{
	Upp::memcpy64(p, q, счёт);
}

проц копирпам128(ук p, кук q, т_мера счёт)
{
	Upp::memcpy128(p, q, счёт);
}

//////////////////////////////

бул равнпам8(кук p, кук q, т_мера счёт)
{
	return Upp::memeq8(p, q, счёт);
}

бул равнпам16(кук p, кук q, т_мера счёт)
{
	return Upp::memeq16(p, q, счёт);
}

бул равнпам32(кук p, кук q, т_мера счёт)
{
	return Upp::memeq32(p, q, счёт);
}

бул равнпам64(кук p, кук q, т_мера счёт)
{
	return Upp::memeq64(p, q, счёт);
}

бул равнпам128(кук p, кук q, т_мера счёт)
{
	return Upp::memeq128(p, q, счёт);
}

///////////////////
т_хэш хэшпам(кук укз, т_мера счёт)
{
	return Upp::memhash(укз, счёт);
}
//////////////
бул нч_ли(дво d)        { return std::isnan(d); }
бул беск_ли(дво d)        { return std::isinf(d); }
бул конечен(дво d)        { return !нч_ли(d) && !беск_ли(d); }
/////////////////
проц заполни(сим *t, кткст0 lim, const сим& x)
{ устпам8(t, x, т_мера(lim - t)); }

проц копируй(сим *dst, кткст0 ист, кткст0 lim)
{ копирпам8( (ук)dst, (ук)ист, т_мера((ббайт *)lim - (ббайт *)ист)); }

проц заполни(байт *t, const байт *lim, const байт& x)
{ устпам8(t, x, т_мера(lim - t)); }

проц копируй(байт *dst, const байт *ист, const байт *lim)
{ копирпам8((ук)dst,(ук) ист, т_мера((ббайт *)lim - (ббайт *)ист)); }

проц заполни(ббайт *t, const ббайт *lim, const ббайт& x)
{ устпам8(t, x, т_мера(lim - t)); }

проц копируй(ббайт *dst, const ббайт *ист, const ббайт *lim)
{ копирпам8((ук)dst, (ук)ист, т_мера((ббайт *)lim - (ббайт *)ист)); }

/////////////////////////
бул  пусто_ли(const цел& i)     { return i == ЦЕЛ_НУЛЛ; }
бул  пусто_ли(const дол& i)   { return i == ЦЕЛ64_НУЛЛ; }
бул  пусто_ли(const дво& r)  { return !(std::abs(r) < std::numeric_limits<дво>::infinity()); }
бул  пусто_ли(const бул& r  )  { return false; }

////////
цел сравниЗнак(const сим& a, const сим& b)                     { return сравниЧисла__(a, b); }
цел сравниЗнак(const байт& a, const байт& b)       { return сравниЧисла__(a, b); }
цел сравниЗнак(const ббайт& a, const ббайт& b)   { return сравниЧисла__(a, b); }
цел сравниЗнак(const крат& a, const крат& b)                   { return сравниЧисла__(a, b); }
цел сравниЗнак(const бкрат& a, const бкрат& b) { return сравниЧисла__(a, b); }
цел сравниЗнак(const цел& a, const цел& b)                       { return сравниЧисла__(a, b); }
цел сравниЗнак(const бцел& a, const бцел& b)     { return сравниЧисла__(a, b); }
цел сравниЗнак(const long& a, const long& b)                     { return сравниЧисла__(a, b); }
цел сравниЗнак(const unsigned long& a, const unsigned long& b)   { return сравниЧисла__(a, b); }
цел сравниЗнак(const бул& a, const бул& b)                     { return сравниЧисла__(a, b); }
цел сравниЗнак(const дол& a, const дол& b)                   { return сравниЧисла__(a, b); }
цел сравниЗнак(const бдол& a, const бдол& b)                 { return сравниЧисла__(a, b); }
цел сравниЗнак(const плав& a, const плав& b)                   { return сравниЧисла__(a, b); }
цел сравниЗнак(const дво& a, const дво& b)                 { return сравниЧисла__(a, b); }

т_хэш дайХэшЗнач(const сим& a)           { return (т_хэш)a; }
т_хэш дайХэшЗнач(const байт& a)    { return (const т_хэш)a; }
т_хэш дайХэшЗнач(const ббайт& a)  { return (const т_хэш)a; }
т_хэш дайХэшЗнач(const крат& a)          { return (const т_хэш)a; }
т_хэш дайХэшЗнач(const бкрат& a) { return (const т_хэш)a; }
т_хэш дайХэшЗнач(const цел& a)            { return (const т_хэш)a; }
т_хэш дайХэшЗнач(const бцел& a)   { return (const т_хэш)a; }
т_хэш дайХэшЗнач(const long& a)           { return (const т_хэш)a; }
т_хэш дайХэшЗнач(const unsigned long& a)  { return (const т_хэш)a; }
т_хэш дайХэшЗнач(const бул& a)           { return (const т_хэш)a; }
т_хэш дайХэшЗнач(const wchar_t& a)        { return (const т_хэш)a; }

#ifdef ХЭШ64
т_хэш дайХэшЗнач(const дол& a)          { return (const т_хэш)a; }
т_хэш дайХэшЗнач(const бдол& a)         { return (const т_хэш)a; }
#else
т_хэш дайХэшЗнач(const дол& a)          { return КомбХэш((т_хэш)a, (т_хэш)(a >> 32)); }
т_хэш дайХэшЗнач(const бдол& a)         { return дайХэшЗнач((дол)a); }
#endif

т_хэш дайХэшЗнач(const дво& a)         { return хэшпам((ук) &a, sizeof(a)); }
т_хэш дайХэшЗнач(const плав& a)          { дво хэшпам(&a, sizeof(a)); }

#ifdef CPU_32
т_хэш дайХэшЗначУкз(кук a)                   { return (цел)a; }
#else
т_хэш дайХэшЗначУкз(кук a)                   { return КомбХэш((т_хэш)(uintptr_t)a); }
#endif

//////////////////////////////////

бул  пробуйПереместПам(ук укз, т_мера& newsize) {
	return Upp::MemoryпробуйПеремест(укз, newsize);
}

ук разместиТини(цел size) {
	return Upp::TinyAlloc(size);
}

проц освободиТини(цел size, ук укз)
{
	цел k = классТини__(size);
	if(k < 0)
		освободиПам(укз);
	else
		освободиПамk__(k, укз);
}

#else

ОпцииПамяти::ОпцииПамяти() {}
ОпцииПамяти::~ОпцииПамяти() {}

#ifndef flagHEAPOVERRIDE

 ук разместиПамПерманентно(т_мера size)                { return malloc(size); }
 ук разместиПам(т_мера size)     { return new ббайт[size]; }
 ук разместиПамТн(т_мера &size)  { return new ббайт[size]; }
 проц   освободиПам(ук p)          { delete[] (ббайт *) p; }
 ук разместиПам32()              { return new ббайт[32]; }
 ук разместиПам48()              { return new ббайт[48]; }
 проц   освободиПам32(ук укз)      { delete[] (ббайт *)укз; }
 проц   освободиПам48(ук укз)      { delete[] (ббайт *)укз; }
 проц   диагнозИницПам()      {}
 проц   проверьПам() {}
 проц   MemoryCheckDebug() {}
 цел    MemoryUsedKb() { return 0; }
 цел    MemoryUsedKbMax() { return 0; }

 проц   MemoryIgnoreLeaksBegin() {}
 проц   MemoryIgnoreLeaksEnd() {}

 т_мера дайРазмБлокаПам(ук укз) { return 0; }

 бул   пробуйПереместПам(ук укз, т_мера& newsize) { return false; }

struct ПрофильПамяти {
	цел empty__;
};

 ПрофильПамяти *PeakMemoryProfile() { return NULL; }

 ук разместиТини(цел size) { return разместиПам(size); }

 проц освободиТини(цел, ук укз) { return освободиПам(укз); }

#endif
#endif

бцел номерТипаЗнач(const цел*)     { return INT_V; }
бцел номерТипаЗнач(const дол*)   { return INT64_V; }
бцел номерТипаЗнач(const дво*)  { return DOUBLE_V; }
бцел номерТипаЗнач(const бул*)    { return BOOL_V; }
бцел номерТипаЗнач(const Ткст*)  { return STRING_V; }
бцел номерТипаЗнач(const ШТкст*) { return WSTRING_V; }
бцел номерТипаЗнач(const Дата*)    { return DATE_V; }
бцел номерТипаЗнач(const Время*)    { return TIME_V; }
бцел номерТипаЗнач(const Значение*)   { return VALUE_V; }

#if defined(CPU_UNALIGNED) && defined(CPU_LE)
НЕСАННЕОПР  цел    подбери16лэ(кук укз)  { return *(const бкрат *)укз; }
НЕСАННЕОПР  цел    подбери32лэ(кук укз)  { return *(const бцел *)укз; }
НЕСАННЕОПР  дол  подбери64лэ(кук укз)  { return *(const дол *)укз; }

НЕСАННЕОПР  проц   помести16лэ(кук укз, цел знач)    { *(бкрат *)укз = знач; }
НЕСАННЕОПР  проц   помести32лэ(кук укз, цел знач)    { *(бцел *)укз = знач; }
НЕСАННЕОПР  проц   помести64лэ(кук укз, дол знач)  { *(дол *)укз = знач; }
#else
 цел    подбери16лэ(кук укз)  { return MAKEWORD(((ббайт *)укз)[0], ((ббайт *)укз)[1]); }
 цел    подбери32лэ(кук укз)  { return MAKELONG(подбери16лэ(укз), подбери16лэ((ббайт *)укз + 2)); }
 дол  подбери64лэ(кук укз)  { return СДЕЛАЙБДОЛ(подбери32лэ(укз), подбери32лэ((ббайт *)укз + 4)); }

 проц   помести16лэ(кук укз, цел знач)    { ((ббайт *)укз)[0] = LOBYTE(знач); ((ббайт *)укз)[1] = HIBYTE(знач); }
 проц   помести32лэ(кук укз, цел знач)    { помести16лэ(укз, LOWORD(знач)); помести16лэ((ббайт *)укз + 2, HIWORD(знач)); }
 проц   помести64лэ(кук укз, дол знач)  { помести32лэ(укз, МЛБЦЕЛ(знач)); помести32лэ((ббайт *)укз + 4, СДЕЛАЙБЦЕЛ(знач)); }
#endif

 цел    подбери16бэ(кук укз)  { return MAKEWORD(((ббайт *)укз)[1], ((ббайт *)укз)[0]); }
 цел    подбери32бэ(кук укз)  { return MAKELONG(подбери16бэ((ббайт *)укз + 2), подбери16бэ(укз)); }
 дол  подбери64бэ(кук укз)  { return СДЕЛАЙБДОЛ(подбери32бэ((ббайт *)укз + 4), подбери32бэ(укз)); }

 проц   помести16бэ(кук укз, цел знач)    { ((ббайт *)укз)[1] = LOBYTE(знач); ((ббайт *)укз)[0] = HIBYTE(знач); }
 проц   помести32бэ(кук укз, цел знач)    { помести16бэ(укз, HIWORD(знач)); помести16бэ((ббайт *)укз + 2, LOWORD(знач)); }
 проц   помести64бэ(кук укз, дол знач)  { помести32бэ(укз, СДЕЛАЙБЦЕЛ(знач)); помести32бэ((ббайт *)укз + 4, МЛБЦЕЛ(знач)); }

#ifdef CPU_LITTLE_ENDIAN

#define СДЕЛАЙ2Б(b0, b1)                            MAKEWORD(b0, b1)
#define СДЕЛАЙ4Б(b0, b1, b2, b3)                    MAKELONG(MAKEWORD(b0, b1), MAKEWORD(b2, b3))
#define СДЕЛАЙ8Б(b0, b1, b2, b3, b4, b5, b6, b7)    СДЕЛАЙБДОЛ(СДЕЛАЙ4Б(b0, b1, b2, b3), СДЕЛАЙ4Б(b4, b5, b6, b7))

 цел    подбери16(кук укз)  { return подбери16лэ(укз); }
 цел    подбери32(кук укз)  { return подбери32лэ(укз); }
 дол  подбери64(кук укз)  { return подбери64лэ(укз); }

 проц   помести16(кук укз, цел знач)    { помести16лэ(укз, знач); }
 проц   помести32(кук укз, цел знач)    { помести32лэ(укз, знач); }
 проц   помести64(кук укз, дол знач)  { помести64лэ(укз, знач); }

#else

#define СДЕЛАЙ2Б(b0, b1)                            MAKEWORD(b1, b0);
#define СДЕЛАЙ4Б(b0, b1, b2, b3)                    MAKELONG(MAKEWORD(b2, b3), MAKEWORD(b0, b1))
#define СДЕЛАЙ8Б(b0, b1, b2, b3, b4, b5, b6, b7)    СДЕЛАЙБДОЛ(СДЕЛАЙ4Б(b7, b6, b5, b4), СДЕЛАЙ4Б(b3, b2, b1, b0))

 цел    подбери16(кук укз)  { return подбери16бэ(укз); }
 цел    подбери32(кук укз)  { return подбери32бэ(укз); }
 дол  подбери64(кук укз)  { return подбери64бэ(укз); }

 проц   помести16(кук укз, цел знач)    { помести16бэ(укз, знач); }
 проц   помести32(кук укз, цел знач)    { помести32бэ(укз, знач); }
 проц   помести64(кук укз, дол знач)  { помести64бэ(укз, знач); }

#endif

#if defined(CPU_X86) && defined(COMPILER_MSC)
#ifdef COMPILER_GCC
#ifdef CPU_64
 бкрат   эндианРазворот16(бкрат v)    { __asm__("xchgb %b0,%h0" : "=Q" (v) :  "0" (v)); return v; }
 крат  эндианРазворот16(крат v)   { __asm__("xchgb %b0,%h0" : "=Q" (v) :  "0" (v)); return v; }
#else
 бкрат   эндианРазворот16(бкрат v)    { __asm__("xchgb %b0,%h0" : "=q" (v) :  "0" (v)); return v; }
 крат  эндианРазворот16(крат v)   { __asm__("xchgb %b0,%h0" : "=q" (v) :  "0" (v)); return v; }
#endif
 бцел  эндианРазворот32(бцел v)   { __asm__("bswap %0" : "=r" (v) : "0" (v)); return v; }
 цел    эндианРазворот32(цел v)     { __asm__("bswap %0" : "=r" (v) : "0" (v)); return v; }
#endif

#ifdef COMPILER_MSC
#pragma intrinsic (_byteswap_ushort, _byteswap_ulong, _byteswap_uint64, strlen)

 бкрат   эндианРазворот16(бкрат v)    { return _byteswap_ushort(v); }
 крат  эндианРазворот16(крат v)   { return _byteswap_ushort(v); }
 бцел  эндианРазворот32(бцел v)   { return _byteswap_ulong(v); }
 цел    эндианРазворот32(цел v)     { return _byteswap_ulong(v); }
#endif

 проц   эндианРазворот(бкрат& v)     { v = эндианРазворот16(v); }
 проц   эндианРазворот(крат& v)    { v = эндианРазворот16(v); }
 проц   эндианРазворот(бцел& v)    { v = эндианРазворот32(v); }
 проц   эндианРазворот(цел& v)      { v = эндианРазворот32(v); }

#else

#ifdef COMPILER_GCC

 бцел  эндианРазворот32(бцел v)   { return __builtin_bswap32(v); }
 цел    эндианРазворот32(цел v)     { return __builtin_bswap32(v); }

 бкрат   эндианРазворот16(бкрат v)    { return эндианРазворот32(v) >> 16; } // GCC bug workaround
 крат  эндианРазворот16(крат v)   { return эндианРазворот32(v) >> 16; }

 проц   эндианРазворот(бкрат& v)     { v = эндианРазворот16(v); }
 проц   эндианРазворот(крат& v)    { v = эндианРазворот16(v); }
 проц   эндианРазворот(бцел& v)    { v = эндианРазворот32(v); }
 проц   эндианРазворот(цел& v)      { v = эндианРазворот32(v); }

#else

 проц   эндианРазворот(бкрат& v)     { ббайт *x = (ббайт *)(&v); разверни(x[0], x[1]); }
 проц   эндианРазворот(крат& v)    { эндианРазворот(*(бкрат *)&v); }
 проц   эндианРазворот(бцел& v)    { ббайт *x = (ббайт *)&v; разверни(x[0], x[3]); разверни(x[1], x[2]); }
 проц   эндианРазворот(цел& v)      { эндианРазворот(*(бцел *)&v); }
 бкрат   эндианРазворот16(бкрат v)    { эндианРазворот(v); return v; }
 крат  эндианРазворот16(крат v)   { эндианРазворот(v); return v; }
 бцел  эндианРазворот32(бцел v)   { эндианРазворот(v); return v; }
 цел    эндианРазворот32(цел v)     { эндианРазворот(v); return v; }

#endif

#endif

#if defined(CPU_AMD64) && (defined(COMPILER_GCC) || defined(COMPILER_MSC))
#ifdef COMPILER_GCC
 бдол  эндианРазворот64(бдол v) { __asm__("bswap %0" : "=r" (v) : "0" (v)); return v; }
 дол   эндианРазворот64(дол v)  { __asm__("bswap %0" : "=r" (v) : "0" (v)); return v; }
#endif
#ifdef COMPILER_MSC
 бдол  эндианРазворот64(бдол v) { return _byteswap_uint64(v); }
 дол   эндианРазворот64(дол v)  { return _byteswap_uint64(v); }
#endif

 проц   эндианРазворот(дол& v)    { v = эндианРазворот64(v); }
 проц   эндианРазворот(бдол& v)   { v = эндианРазворот64(v); }

#else

#ifdef COMPILER_GCC

 бдол  эндианРазворот64(бдол v) { return __builtin_bswap64(v); }
 дол   эндианРазворот64(дол v)  { return __builtin_bswap64(v); }

 проц    эндианРазворот(дол& v)   { v = эндианРазворот64(v); }
 проц    эндианРазворот(бдол& v)  { v = эндианРазворот64(v); }

#else
 проц   эндианРазворот(дол& v)    { ббайт *x = (ббайт *)&v; разверни(x[0], x[7]); разверни(x[1], x[6]); разверни(x[2], x[5]); разверни(x[3], x[4]); }
 проц   эндианРазворот(бдол& v)   { эндианРазворот(*(дол *)&v); }
 дол  эндианРазворот64(дол v)   { эндианРазворот(v); return v; }
 бдол эндианРазворот64(бдол v)  { эндианРазворот(v); return v; }
#endif
#endif

 бкрат   эндианРазворот16(цел w)     { return эндианРазворот16((бкрат)w); }
 бкрат   эндианРазворот16(бцел w)   { return эндианРазворот16((бкрат)w); }

проц эндианРазворот(бкрат *v, т_мера count);
проц эндианРазворот(крат *v, т_мера count);
проц эндианРазворот(бцел *v, т_мера count);
проц эндианРазворот(цел *v, т_мера count);
проц эндианРазворот(дол *v, т_мера count);
проц эндианРазворот(бдол *v, т_мера count);

#ifdef CPU_64

 бцел складиХэш(дим h)
{
	return (бцел)эндианРазворот64(ХЭШ_КОНСТ3 * h);
}

#else

 бцел складиХэш(бцел h)
{
	return эндианРазворот32(ХЭШ_КОНСТ3 * h);
}

#endif


цел значимыеБиты(бцел x)
{ // basically log2(x) + 1 except that for 0 this is 0, number of significant bits of x
#ifdef COMPILER_MSC
	DWORD индекс;
	return _BitScanReverse(&индекс, x) ? индекс + 1 : 0;
#else
	return x ? 32 - __builtin_clz(x) : 0;
#endif
}


цел значимыеБиты64(бдол x)
{ // basically log2(x) + 1 except that for 0 this is 0, number of significant bits of x
#ifdef COMPILER_MSC
#ifdef CPU_64
	DWORD индекс;
	return _BitScanReverse64(&индекс, x) ? индекс + 1 : 0;
#else
	if(x & 0xffffffff00000000)
		return значимыеБиты(СДЕЛАЙБЦЕЛ(x)) + 32;
	else
		return значимыеБиты((DWORD)x);
#endif
#else
	return x ? 64 - __builtin_clzll(x) : 0;
#endif
}

 бул вмещаетсяВЦел64(дво x)
{
	return x >= -9223372036854775808.0 && x < 9223372036854775808.0;
}

#if defined(__SIZEOF_INT128__) && (__GNUC__ > 5 || __clang_major__ >= 5)

#ifdef CPU_X86

ббайт сложик64(бдол& result, const бдол& значение, ббайт carry) {
	return _addcarry_u64(carry, result, значение, &result);
}

#else


ббайт сложик64(бдол& r, бдол a, ббайт carry)
{
	uint64_t r1 = r;
	r += a + carry;
	return carry ? r <= a : r < a;
}

#endif


бдол умножь64(бдол a, бдол b, бдол& hi)
{
	unsigned __int128 prod =  (unsigned __int128)a * b;
	hi = prod >> 64;
	return prod;
}

#elif defined(COMPILER_MSC) && defined(CPU_64)


бдол умножь64(бдол a, бдол b, бдол& hi)
{
	return _umul128(a, b, &hi);
}


ббайт сложик64(бдол& result, const бдол& значение, ббайт carry) {
	return _addcarry_u64(carry, result, значение, &result);
}

#else


ббайт сложик64(бдол& r, бдол a, ббайт carry)
{
	uint64_t r1 = r;
	r += a + carry;
	return carry ? r <= a : r < a;
}


бдол умножь64(бдол a, бдол b, бдол& hi)
{
	бдол lo_lo = (a & 0xFFFFFFFF) * (b & 0xFFFFFFFF);
	бдол hi_lo = (a >> 32)        * (b & 0xFFFFFFFF);
	бдол lo_hi = (a & 0xFFFFFFFF) * (b >> 32);
	бдол hi_hi = (a >> 32)        * (b >> 32);
	
	бдол cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFF) + lo_hi;
	hi = (hi_lo >> 32) + (cross >> 32)        + hi_hi;

	return (cross << 32) | (lo_lo & 0xFFFFFFFF);
}

#endif


цел сравнилюб(кткст0 a, const Ткст& b) {
	return -сравнилюб(b, a);
}

Ткст обрежьЛево(кткст0 prefix, const Ткст& s)    { return обрежьЛево(prefix, (цел)strlen(prefix), s); }
Ткст обрежьЛево(const Ткст& prefix, const Ткст& s)  { return обрежьЛево(~prefix, prefix.дайСчёт(), s); }
Ткст обрежьПраво(кткст0 suffix, const Ткст& s)   { return обрежьПраво(suffix, (цел)strlen(suffix), s); }
Ткст обрежьПраво(const Ткст& suffix, const Ткст& s) { return обрежьПраво(~suffix, suffix.дайСчёт(), s); }

бул  пустой(const ШТкст& s)      { return s.пустой(); }

цел сравнилюб(const шим *a, const ШТкст& b) {
	return -сравнилюб(b, a);
}



