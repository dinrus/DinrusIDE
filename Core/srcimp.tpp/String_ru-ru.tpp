topic "Классы String и WString";
[i448;a25;kKO9;*@(64)2 $$1,0#37138531426314131252341829483380:class]
[l288;2 $$2,2#27521748481378242620020725143825:desc]
[a83;*R6 $$3,0#31310162474203024125188417583966:caption]
[l288;i1121;b17;O9;~~~.1408;2 $$4,0#10431211400427159095818037425705:param]
[i448;a25;kKO9;*@(64)2 $$5,0#37138531426314131252341829483370:item]
[*+117 $$6,6#14700283458701402223321329925657:header]
[l416;2 $$7,7#55548704457842300043401641954952:nested`-desc]
[l288;i448;a25;kO9;*2 $$8,8#64691275497409617375831514634295:nested`-class]
[2 $$0,0#00000000000000000000000000000000:Default]
[{_}%RU-RU 
[s3; Классы String и WString&]
[s0; Реализация в Core классов String и WString 
полностью независимая.&]
[s0; &]
[s0; Реализация в Core представлена классами 
String0 и WString0. Общие методы разделяются 
обоими и далее добавляются в помощью 
шаблона AString (который наследует либо 
String0, либо WString0). Затем реализация 
финализируется в классах String и WString 
(final classes).&]
[s0; &]
[s6; Класс String&]
[s0; String для увеличения производительности 
использует трёх шаговую реализацию.&]
[s0; &]
[s0; String`'и длиной до 14 символов (байтов) 
могут сохраняться с применением small`-string 
оптимизации внутри значения String. 
sizeof(String) равна 16; первые 14 байтов (0`- 
13) в данном случае являются символьными 
данными, байт 14 зарезервирован под 
терминатор ноль (zero terminator) (и для этого 
типа всегда равен нулю), байт 15 это 
длина строки. Также, для этого первого 
рода строк, все символы len ... 14 строго 
хранят ноль `- это позволяет реализовать 
очень быстрое сравнение на равенство.&]
[s0; &]
[s0; Для строк длиною до 31 символа, байты 
0`-7 используются под указатель на 
символьные данные. Символьные данные 
размещаются как блок в 32 байта (один 
байт под терминатор ноль); реализация 
String прямо соединена с разместителем 
кучи, передавая ему обработку размера 
и позволяя добиваться максимальной 
производительности. Длина String хранится 
в байтах 8`-11. Байт 14 в данном случае 
становится 31 (`"MEDIUM`") `- это максимальное 
число, которое можно сохранить в буфере. 
Заметьте, что ненулевое значение 
в байте 14 сигнализирует о том, что 
эта строка не `"маленькая`". При копировании 
строки типа String этого размера, всегда 
размещается новый блок памяти, куда 
копируются данные. С прямой связкой 
с разместителем кучи, это почти так 
же быстро, как использование подсчёта 
ссылок в однопоточном режиме, и ещё 
быстрее в многопоточном.&]
[s0; &]
[s0; Наконец, если размер превышает 31 
символ, в String используется подсчёт 
ссылок (reference counting). Выкладка (Layout) 
подобна `"MEDIUM`", но у блока памяти переменная 
длина и вначале указывается счёт 
ссылок и размер блока (`"alloc`") `- максимальное 
число символов, которое может сохранить 
данный блок. Заметьте, что в качестве 
оптимизации, для блоков, меньших 255 
символов, это число также сохраняется 
в байте 14 для его ускоренного получения. 
Если блок больше, 255 находится в байте 
14, а размер `"alloc`"  нужно получать из 
блока памяти.&]
[s0; &]
[s6; Класс WString&]
[s0; В реализации WString не используется 
оптимизация малой строки (small string 
optimization), первым шагом сохраняется 
23 wchar в блоке памяти размером в 48 байтов, 
без подсчёта ссылок; для строк большего 
размера, опять же, применяется подсчёт 
ссылок. Размеры также прямо сохраняются 
в переменных`-членах `"int`".&]
[s0; ]]