#include "Core.h"

namespace РНЦПДинрус {

static Ткст sAsString(const Вектор<Значение>& v);

#define LTIMING(x) // RTIMING(x)

struct Реф::ValueRef : public РефМенеджер {
	virtual int   дайТип()                            { return VALUE_V; }
	virtual Значение дайЗначение(const void *ptr)            { return *(Значение *) ptr; }
	virtual bool  пусто_ли(const void *ptr)              { return РНЦП::пусто_ли(*(Значение *) ptr); }
	virtual void  устЗначение(void *ptr, const Значение& v)  { *(Значение *) ptr = v; }
	virtual void  устПусто(void *ptr)                   { *(Значение *) ptr = Null; }
};

Реф::Реф(Ткст& s)  { ptr = &s; m = &Single< StdRef<Ткст> >(); }
Реф::Реф(ШТкст& s) { ptr = &s; m = &Single< StdRef<ШТкст> >(); }
Реф::Реф(int& i)     { ptr = &i; m = &Single< StdRef<int> >(); }
Реф::Реф(int64& i)   { ptr = &i; m = &Single< StdRef<int64> >(); }
Реф::Реф(double& d)  { ptr = &d; m = &Single< StdRef<double> >(); }
Реф::Реф(bool& b)    { ptr = &b; m = &Single< StdRef<bool> >(); }
Реф::Реф(Дата& d)    { ptr = &d; m = &Single< StdRef<Дата> >(); }
Реф::Реф(Время& t)    { ptr = &t; m = &Single< StdRef<Время> >(); }
Реф::Реф(Значение& v)   { ptr = &v; m = &Single< ValueRef >(); }

// ----------------------------------

bool МассивЗнач::Данные::пусто_ли() const
{
	return данные.пустой();
}

void МассивЗнач::Данные::сериализуй(Поток& s)
{
	s % данные;
}

void МассивЗнач::Данные::вДжейсон(ДжейсонВВ& jio)
{
	РНЦПДинрус::вДжейсон(jio, данные);
}

void МассивЗнач::Данные::вРяр(РярВВ& io)
{
	РНЦПДинрус::вРяр(io, данные);
}

hash_t МассивЗнач::Данные::дайХэшЗнач() const
{
	комбинируйХэш w(данные.дайСчёт());
	for(int i = 0; i < данные.дайСчёт(); i++)
		w.помести(данные[i].дайХэшЗнач());
	return w;
}

bool МассивЗнач::Данные::равен(const Значение::Проц *p)
{
	return ((Данные *)p)->данные == данные;
}

int МассивЗнач::Данные::сравни(const Значение::Проц *p)
{
	return данные.сравни(((Данные *)p)->данные);
}

bool МассивЗнач::operator==(const МассивЗнач& v) const
{
	return v.данные->данные == данные->данные;
}

int МассивЗнач::сравни(const МассивЗнач& b) const
{
	return данные->данные.сравни(b.данные->данные);
}

static Ткст sAsString(const Вектор<Значение>& v)
{
	Ткст s;
	s << "[";
	for(int i = 0; i < v.дайСчёт(); i++) {
		if(i) s << ", ";
		s << v[i];
	}
	s << "]";
	return s;
}

Ткст МассивЗнач::Данные::какТкст() const
{
	return sAsString(данные);
}

Вектор<Значение> МассивЗнач::VoidData;

Вектор<Значение>& МассивЗнач::создай()
{
	данные = new Данные;
	return данные->данные;
}

Вектор<Значение>& МассивЗнач::клонируй() {
	if(данные->GetRefCount() != 1) {
		Данные *d = new Данные;
		d->данные = clone(данные->данные);
		данные->отпусти();
		данные = d;
	}
	return данные->данные;
}

void МассивЗнач::иниц0()
{
	данные = &Single<ДанныеПусто>();
	данные->Retain();
}

МассивЗнач::МассивЗнач(const МассивЗнач& v) {
	данные = v.данные;
	данные->Retain();
}

МассивЗнач::МассивЗнач(МассивЗнач&& v) {
	данные = v.данные;
	v.иниц0();
}

МассивЗнач::МассивЗнач(Вектор<Значение>&& v)
{
	создай() = pick(v);
}

МассивЗнач::МассивЗнач(const Вектор<Значение>& v, int deep)
{
	создай() = clone(v);
}

МассивЗнач::operator Значение() const {
	данные->Retain();
	return Значение(данные, VALUEARRAY_V);
}

МассивЗнач::МассивЗнач(const Значение& ист)
{
	if(!РНЦП::пусто_ли(ист)) {
		if(ист.является<МапЗнач>()) {
			МассивЗнач v = МапЗнач(ист);
			данные = v.данные;
			данные->Retain();
			return;
		}
		else {
			if(ист.дайТип() != VALUEARRAY_V)
				throw ОшибкаТипаЗначения(Ткст().конкат() << "Invalid значение conversion: "
			                         << ист.дайИмяТипа() << " -> МассивЗнач",
			                         ист, VALUEARRAY_V);
			данные = (МассивЗнач::Данные *)ист.дайПроцУк();
		}
	}
	else
		данные = &Single<ДанныеПусто>();
	данные->Retain();
}

void МассивЗнач::сериализуй(Поток& s) {
	if(s.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->сериализуй(s);
}

void МассивЗнач::вДжейсон(ДжейсонВВ& jio)
{
	if(jio.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->вДжейсон(jio);
}

void МассивЗнач::вРяр(РярВВ& xio)
{
	if(xio.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->вРяр(xio);
}

Ткст МассивЗнач::вТкст() const
{
	return sAsString(дай());
}

МассивЗнач::~МассивЗнач() {
	ПРОВЕРЬ(данные->GetRefCount() > 0);
	данные->отпусти();
}

МассивЗнач& МассивЗнач::operator=(const МассивЗнач& v) {
	v.данные->Retain();
	данные->отпусти();
	данные = v.данные;
	return *this;
}

void МассивЗнач::устСчёт(int n)
{
	клонируй().устСчёт(n);
}

void МассивЗнач::устСчёт(int n, const Значение& v)
{
	клонируй().устСчёт(n, v);
}

void МассивЗнач::очисть() {
	клонируй().очисть();
}

void МассивЗнач::добавь(const Значение& v) {
	клонируй().добавь(v);
}

void МассивЗнач::уст(int i, const Значение& v) {
#if !defined(_MSC_VER) || _MSC_VER > 1310
	ПРОВЕРЬ(i >= 0);
	клонируй().по(i) = v;
#else
	throw 0;
#endif
}

Значение& МассивЗнач::по(int i)
{
	return клонируй().по(i);
}

void МассивЗнач::удали(int i, int count)
{
	клонируй().удали(i, count);
}

void МассивЗнач::удали(const Вектор<int>& ii)
{
	клонируй().удали(ii);
}

void МассивЗнач::вставь(int i, const МассивЗнач& va)
{
	if(va.данные == данные) {
		МассивЗнач va2 = va;
		клонируй().вставь(i, va2.дай());
	}
	else
		клонируй().вставь(i, va.дай());
}

const Значение& МассивЗнач::дай(int i) const {
	ПРОВЕРЬ(i >= 0 && i < дайСчёт());
	return данные->данные[i];
}

Значение МассивЗнач::дайИОчисть(int i)
{
	ПРОВЕРЬ(i >= 0 && i < дайСчёт());
	Вектор<Значение>& x = клонируй();
	Значение v = x[i];
	x[i] = Значение();
	return v;
}

Вектор<Значение> МассивЗнач::подбери()
{
	Вектор<Значение>& x = клонируй();
	Вектор<Значение> r = pick(x);
	x.очисть();
	return r;
}

template<>
Ткст какТкст(const МассивЗнач& v) {
	return sAsString(v.дай());
}

bool МапЗнач::Данные::пусто_ли() const {
	return this == &Single<МапЗнач::ДанныеПусто>();
}

void МапЗнач::Данные::сериализуй(Поток& s) {
	s % ключ % значение;
}

void МапЗнач::Данные::вРяр(РярВВ& xio)
{
	РНЦПДинрус::вРяр(xio, ключ);
	РНЦПДинрус::вРяр(xio, значение);
}

void МапЗнач::Данные::вДжейсон(ДжейсонВВ& jio)
{
	if(jio.сохраняется()) {
		МассивЗнач va;
		int n = min(значение.дайСчёт(), ключ.дайСчёт());
		for(int i = 0; i < n; i++) {
			МапЗнач m;
			m.добавь("ключ", StoreAsJsonValue(ключ[i]));
			m.добавь("значение", StoreAsJsonValue(значение[i]));
			va.добавь(m);
		}
		jio.уст(va);
	}
	else {
		Значение va = jio.дай();
		ключ.очисть();
		значение.очисть();
		for(int i = 0; i < va.дайСчёт(); i++) {
			Значение k, v;
			LoadFromJsonValue(k, va[i]["ключ"]);
			LoadFromJsonValue(v, va[i]["значение"]);
			ключ.добавь(k);
			значение.добавь(v);
		}
	}
}

hash_t МапЗнач::Данные::дайХэшЗнач() const {
	комбинируйХэш w(ключ.дайСчёт());
	for(int i = 0; i < ключ.дайСчёт(); i++)
		w.помести(ключ[i].дайХэшЗнач());
	w.помести(значение.дайХэшЗнач());
	return w;
}

static bool sIsEqual(const Индекс<Значение>& a, const Индекс<Значение>& b)
{
	if(&a == &b) return true;
	if(a.дайСчёт() != b.дайСчёт()) return false;
	for(int i = 0; i < a.дайСчёт(); i++)
		if(a[i] != b[i]) return false;
	return true;
}

bool МапЗнач::Данные::равен(const Значение::Проц *p)
{
	return sIsEqual(((Данные *)p)->ключ, ключ) && ((Данные *)p)->значение == значение;
}

bool МапЗнач::operator==(const МапЗнач& v) const
{
	return sIsEqual(данные->ключ, v.данные->ключ) && данные->значение == v.данные->значение;
}

int  МапЗнач::Данные::сравни(const Значение::Проц *p)
{
	Данные *b = (Данные *)p;
	int n = min(ключ.дайСчёт(), b->ключ.дайСчёт());
	for(int i = 0; i < n; i++) {
		int q = сравниЗнак(ключ[i], b->ключ[i]);
		if(q)
			return q;
		q = сравниЗнак(значение[i], b->значение[i]);
		if(q)
			return q;
	}
	return сравниЗнак(ключ.дайСчёт(), b->ключ.дайСчёт());
}

int МапЗнач::сравни(const МапЗнач& b) const
{
	return данные->сравни((Значение::Проц *)b.данные);
}

bool МапЗнач::одинаково(const МапЗнач& b) const
{
	for(int pass = 0; pass < 2; pass++) {
		const МапЗнач& m = pass ? *this : b;
		const МапЗнач& n = pass ? b : *this;
		for(int i = 0; i < m.дайСчёт(); i++)
			if(!n[m.дайКлюч(i)].одинаково(m.дайЗначение(i)))
				return false;
	}
	return true;
}

Ткст МапЗнач::Данные::какТкст() const
{
	Ткст s;
	s << "{ ";
	for(int i = 0; i < ключ.дайСчёт(); i++) {
		if(i) s << ", ";
		s << ключ[i] << ": " << значение[i];
	}
	s << " }";
	return s;
}

МапЗнач::Данные& МапЗнач::создай()
{
	данные = new Данные;
	return *данные;
}

void МапЗнач::клонируй(Данные *&ptr)
{
	Данные *d = new Данные;
	d->ключ = clone(ptr->ключ);
	d->значение = ptr->значение;
	ptr->отпусти();
	ptr = d;
}

void МапЗнач::иниц0()
{
	данные = &Single<ДанныеПусто>();
	данные->Retain();
}

МапЗнач::МапЗнач(const МапЗнач& v)
{
	данные = v.данные;
	данные->Retain();
}

МапЗнач::МапЗнач(Индекс<Значение>&& k, Вектор<Значение>&& v)
{
	Данные& d = создай();
	d.ключ = pick(k);
	d.значение = МассивЗнач(pick(v));
}

МапЗнач::МапЗнач(ВекторМап<Значение, Значение>&& m)
{
	Данные& d = создай();
	d.ключ = m.подбериКлючи();
	d.значение = МассивЗнач(m.подбериЗначения());
}

МапЗнач::МапЗнач(const Индекс<Значение>& k, const Вектор<Значение>& v, int deep)
{
	Данные& d = создай();
	d.ключ = clone(k);
	d.значение = МассивЗнач(v, 0);
}

МапЗнач::МапЗнач(const ВекторМап<Значение, Значение>& m, int deep)
{
	Данные& d = создай();
	d.ключ = clone(m.дайКлючи());
	d.значение = МассивЗнач(m.дайЗначения(), 0);
}

ВекторМап<Значение, Значение> МапЗнач::подбери()
{
	Данные& d = UnShare();
	ВекторМап<Значение, Значение> m(d.ключ.подбериКлючи(), d.значение.подбери());
	d.ключ.очисть();
	return m;
}

МапЗнач::operator Значение() const {
	данные->Retain();
	return Значение(данные, VALUEMAP_V);
}

void МапЗнач::изМассива(const МассивЗнач& va)
{
	иниц0();
	for(int i = 0; i < va.дайСчёт(); i++)
		добавь(i, va[i]);
}

МапЗнач::МапЗнач(const Значение& ист)
{
	if(!пусто_ли(ист)) {
		if(ист.является<МассивЗнач>()) {
			изМассива(ист);
			return;
		}
		else {
			if(ист.дайТип() != VALUEMAP_V)
				throw ОшибкаТипаЗначения(Ткст().конкат() << "Invalid значение conversion: "
			                         << ист.дайИмяТипа() << " -> МапЗнач",
			                         ист, VALUEMAP_V);
			данные = (МапЗнач::Данные *)ист.дайПроцУк();
		}
	}
	else
		данные = &Single<ДанныеПусто>();
	данные->Retain();
}

void МапЗнач::сериализуй(Поток& s) {
	if(s.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->сериализуй(s);
}

void МапЗнач::вДжейсон(ДжейсонВВ& jio)
{
	if(jio.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->вДжейсон(jio);
}

void МапЗнач::вРяр(РярВВ& xio)
{
	if(xio.грузится()) {
		данные->отпусти();
		создай();
	}
	данные->вРяр(xio);
}

МапЗнач::~МапЗнач() {
	ПРОВЕРЬ(данные->GetRefCount() > 0);
	данные->отпусти();
}

МапЗнач& МапЗнач::operator=(const МапЗнач& v) {
	v.данные->Retain();
	данные->отпусти();
	данные = v.данные;
	return *this;
}

void МапЗнач::очисть() {
	данные->отпусти();
	иниц0();
}

void МапЗнач::уст(const Значение& ключ, const Значение& значение)
{
	Данные& d = UnShare();
	int i = d.ключ.найди(ключ);
	if(i >= 0)
		d.значение.уст(i, значение);
	else {
		d.ключ.добавь(ключ);
		d.значение.добавь(значение);
	}
}

void МапЗнач::устПо(int i, const Значение& v) {
	UnShare().значение.уст(i, v);
}

void МапЗнач::устКлюч(int i, const Значение& k) {
	UnShare().ключ.уст(i, k);
}

int МапЗнач::удалиКлюч(const Значение& ключ)
{
	Данные& d = UnShare();
	Вектор<int> rk;
	int q = d.ключ.найди(ключ);
	while(q >= 0) {
		rk.добавь(q);
		q = d.ключ.найдиСледщ(q);
	}
	if(rk.дайСчёт()) {
		сортируй(rk);
		d.ключ.удали(rk);
		d.значение.удали(rk);
	}
	return rk.дайСчёт();
}

void МапЗнач::удали(int i)
{
	Данные& d = UnShare();
	d.ключ.удали(i);
	d.значение.удали(i);
}

Значение МапЗнач::дайИОчисть(const Значение& ключ)
{
	Данные& d = UnShare();
	int q = d.ключ.найди(ключ);
	return q < 0 ? значОш() : d.значение.дайИОчисть(q);
}

// ----------------------------------

bool StdValuePairOrder::operator()(const Значение& k1, const Значение& v1, const Значение& k2, const Значение& v2) const
{
	int q = сравниСтдЗнач(k1, k2, язык);
	if(q) return q < 0;
	return сравниСтдЗнач(v1, v2, язык);
}

bool FnValuePairOrder::operator()(const Значение& keya, const Значение& valuea, const Значение& keyb, const Значение& valueb) const
{
	return (*фн)(keya, valuea, keyb, valueb) < 0;
}

int CompareStrings(const Значение& a, const Значение& b, const LanguageInfo& f)
{
	return f.сравни(ШТкст(a), ШТкст(b));
}

void Комплекс::вРяр(РярВВ& xio)
{
	double r, i;
	r = real(); i = imag();
	xio.Атр("real", r).Атр("imag", i);
	*this = C(r, i);
}

void Комплекс::вДжейсон(ДжейсонВВ& jio)
{
	double r, i;
	r = real(); i = imag();
	jio("real", r)("imag", i);
	*this = C(r, i);
}

void Комплекс::сериализуй(Поток& s)
{
	double r, i;
	r = real(); i = imag();
	s % r % i;
	*this = C(r, i);
}

template <class T>
static void sReg(const char *имя)
{
	if(FitsSvoValue<T>())
		Значение::SvoRegister<T>(имя);
	else
		Значение::регистрируй<T>(имя);
}

ИНИЦБЛОК
{
	sReg<Точка>("Точка");
	sReg<Точка64>("Точка64");
	sReg<ТочкаПЗ>("ТочкаПЗ");
	sReg<Размер>("Размер");
	sReg<Размер64>("Размер64");
	sReg<РазмерПЗ>("РазмерПЗ");
	Значение::регистрируй<Прям>("Прям");
	Значение::регистрируй<Прям64>("Прям64");
	Значение::регистрируй<ПрямПЗ>("ПрямПЗ");
}

}

