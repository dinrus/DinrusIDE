#include <DinrusPro/DinrusPro.h>

namespace ДинрусРНЦП {

const Обнул Null;

#define LTIMING(x) // RTIMING(x)

ОшибкаТипаЗначения::ОшибкаТипаЗначения(const Ткст& text, const Значение& ист, цел target)
:	Искл(text), ист(ист), target(target) {}

т_хэш Значение::дайДрЗначХэш() const {
	if(пусто_ли())
		return 0;
	ббайт st = данные.GetSt();
	if(st == REF)
		return укз()->дайХэшЗнач();
	return svo[st]->дайХэшЗнач(&данные);
}

проц Значение::отпустиРеф()
{
	ПРОВЕРЬ(реф_ли()); // Check that svo тип is not registered as Реф
	укз()->отпусти();
}

проц Значение::RefRetain()
{
	укз()->Retain();
}

Значение& Значение::operator=(const Значение& v) {
	if(this == &v) return *this;
	Значение h = v; // сделай copy a 'v' can be reference to МапЗнач/Массив contained element
	освободиРеф();   // e.g. json = json["foo"]
	данные = h.данные;
	if(реф_ли())
		укз()->Retain();
	return *this;
}

проц Значение::устЛардж(const Значение& v)
{
	if(v.реф_ли()) {
		данные.устМалый(v.данные);
		RefRetain();
	}
	else
		данные.бУст(v.данные);
}

бцел Значение::дайТип() const
{
	if(ткст_ли())
		return STRING_V;
	ббайт st = данные.GetSt();
	return st == REF ? дайРефТип() : st == VOIDV ? VOID_V : st;
}

бул Значение::пусто_ли() const
{
	if(ткст_ли())
		return данные.дайСчёт() == 0;
	цел st = данные.GetSt();
	if(st == VOIDV)
		return true;
	if(st == REF)
		return укз()->пусто_ли();
	return svo[st]->пусто_ли(&данные);
}

бул Значение::полиРавны(const Значение& v) const
{
	цел st = данные.дайСпец();
	if(st == REF)
		return укз()->полиРавны(v);
	if(svo[st] && svo[st]->полиРавны(&данные, v))
		return true;
	return пусто_ли() && v.пусто_ли();
}

бул Значение::operator==(const Значение& v) const {
	if(ткст_ли() && v.ткст_ли())
		return данные == v.данные;
	if(дайТип() != v.дайТип()) {
		if(полиРавны(v) || v.полиРавны(*this))
			return true;
	}
	else {
		цел st = данные.дайСпец();
		if(st == REF) {
			if(укз()->равен(v.укз()))
				return true;
		}
		else
		if(st != VOIDV) {
			if(svo[st]->равен(&данные, &v.данные))
				return true;
		}
	}
	return пусто_ли() && v.пусто_ли();
}

цел Значение::полиСравни(const Значение& v) const
{
	цел st = данные.дайСпец();
	if(st == REF)
		return укз()->полиСравни(v);
	if(st != VOIDV)
		return svo[st]->полиСравни(&данные, v);
	return 0;
}

цел Значение::сравни2(const Значение& v) const
{
	if(ткст_ли() && v.ткст_ли())
		return сравниЗнак(данные, v.данные);
	бцел stw = данные.GetStW();
	if(stw == v.данные.GetStW()) {
		if(stw == Ткст::StW(INT64_V))
			return сравниЗнак(дайСыройСмолл<дол>(), v.дайСыройСмолл<дол>());
		if(stw == Ткст::StW(DATE_V))
			return сравниЗнак(дайСыройСмолл<Дата>(), v.дайСыройСмолл<Дата>());
		if(stw == Ткст::StW(TIME_V))
			return сравниЗнак(дайСыройСмолл<Время>(), v.дайСыройСмолл<Время>());
	}
	бул a = пусто_ли();
	бул b = v.пусто_ли();
	if(a || b)
		return сравниЗнак(b, a);
	цел st = данные.дайСпец();
	if(дайТип() == v.дайТип()) {
		if(st == REF)
			return укз()->сравни(v.укз());
		if(st != VOIDV)
			return svo[st]->сравни(&данные, &v.данные);
	}
	if(st != VOIDV) {
		цел q = полиСравни(v);
		if(q) return q;
		return -v.полиСравни(*this);
	}
	return 0;
}

бул Значение::одинаково(const Значение& b) const
{
	const Значение& a = *this;
	if(a.является<МапЗнач>() && b.является<МапЗнач>())
		return МапЗнач(a).одинаково(МапЗнач(b));
	else
	if(a.является<МассивЗнач>() && b.является<МассивЗнач>()) {
		if(a.дайСчёт() != b.дайСчёт())
			return false;
		for(цел i = 0; i < a.дайСчёт(); i++)
			if(!a[i].одинаково(b[i]))
				return false;
		return true;
	}
	else
		return a == b;
}

Значение::Значение(const ШТкст& s) { иницРеф(new RichValueRep<ШТкст>(s), WSTRING_V); Magic(); }

Значение::operator ШТкст() const
{
	if(пусто_ли()) return Null;
	return дайТип() == WSTRING_V ? To<ШТкст>() : ((Ткст)(*this)).вШТкст();
}

Дата Значение::дайДрДату() const
{
	if(пусто_ли()) return Null;
	return дайСмолл<Время>();
}

Время Значение::дайДрВремя() const
{
	if(пусто_ли()) return Null;
	return воВремя(дайСмолл<Дата>());
}

Ткст Значение::дайДрТкст() const
{
	if(пусто_ли()) return Null;
	if(является<Ткст>())
		return To<Ткст>();
	return To<ШТкст>().вТкст();
}

цел Значение::дайДрЦел() const
{
	if(пусто_ли()) return Null;
	return данные.спец_ли(BOOL_V) ? (цел)дайСмолл<бул>() :
	       данные.спец_ли(INT64_V) ? (цел)дайСмолл<дол>() :
	       (цел)дайСмолл<дво>();
}

дол Значение::дайДрЦел64() const
{
	if(пусто_ли()) return Null;
	return данные.спец_ли(BOOL_V) ? (дол)дайСмолл<бул>() :
	       данные.спец_ли(INT_V) ? (дол)дайСмолл<цел>() :
	       (дол)дайСмолл<дво>();
}

дво Значение::дайДрДво() const
{
	if(пусто_ли()) return Null;
	return данные.спец_ли(BOOL_V) ? (дво)дайСмолл<бул>() :
	       данные.спец_ли(INT_V) ? (дво)дайСмолл<цел>() :
	       (дво)дайСмолл<дол>();
}

бул Значение::дайДрБул() const
{
	if(пусто_ли()) return Null;
	return данные.спец_ли(DOUBLE_V) ? (бул)дайСмолл<дво>() :
	       данные.спец_ли(INT_V) ? (бул)дайСмолл<цел>() :
	       (бул)дайСмолл<дол>();
}

ВекторМап<бцел, Значение::Проц *(*)()>& Значение::Typemap()
{
	static ВекторМап<бцел, Значение::Проц *(*)()> x;
	return x;
}

Индекс<Ткст>& Значение::индексИмени()
{
	static Индекс<Ткст> x;
	return x;
}

Индекс<бцел>& Значение::индексТипа()
{
	static Индекс<бцел> x;
	return x;
}

проц Значение::добавьИмя(бцел тип, кткст0 имя)
{
	индексИмени().добавь(имя);
	индексТипа().добавь(тип);
}

цел Значение::дайТип(кткст0 имя)
{
	цел q = индексИмени().найди(имя);
	if(q < 0)
		return Null;
	return индексТипа()[q];
}

Ткст Значение::дайИмя(бцел тип)
{
	цел q = индексТипа().найди(тип);
	if(q < 0)
		return Null;
	return индексИмени()[q];
}

SVO_FN(s_String, Ткст);
SVO_FN(s_int, цел);
SVO_FN(s_double, дво);
SVO_FN(s_int64, дол);
SVO_FN(s_bool, бул);
SVO_FN(s_date, Дата);
SVO_FN(s_time, Время);

struct SvoVoidFn {
	static бул       пусто_ли(const ук p)                      { return true; }
	static проц       сериализуй(ук p, Поток& s)              {}
	static проц       вРяр(ук p, РярВВ& xio)               {}
	static проц       вДжейсон(ук p, ДжейсонВВ& jio)             {}
	static т_хэш     дайХэшЗнач(const ук p)                { return 0; }
	static бул       равен(const ук p1, const ук p2)    { return true; }
	static бул       полиРавны(const ук p, const Значение& v) { return false; }
	static Ткст     какТкст(const ук p)                    { return Ткст(); }
};

static Значение::Sval s_void = {
	SvoVoidFn::пусто_ли, SvoVoidFn::сериализуй,SvoVoidFn::вРяр, SvoVoidFn::вДжейсон,
	SvoVoidFn::дайХэшЗнач, SvoVoidFn::равен,
	SvoVoidFn::полиРавны, SvoVoidFn::какТкст
};

Значение::Sval *Значение::svo[256] = {
	&s_String, // STRING_V
	&s_int, // INT_V

	&s_double, //DOUBLE_V  = 2;
	&s_void, //VOIDV_V  = 3;
	&s_date, //DATE_V    = 4;
	&s_time, //TIME_V    = 5;

	NULL, //ERROR_V   = 6;

	NULL, //VALUE_V   = 7;

	NULL, //WSTRING_V = 8;

	NULL, //VALUEARRAY_V = 9;

	&s_int64, //INT64_V  = 10;
	&s_bool, //BOOL_V   = 11;

	NULL, //VALUEMAP_V   = 12;
};

Значение::Проц *создайДанМассивЗач()
{
	return new МассивЗнач::Данные;
}

Значение::Проц *создайДанМапЗач()
{
	return new МапЗнач::Данные;
}

проц Значение::регистрируйСтд()
{
	ONCELOCK {
		Значение::регистрируй<ШТкст>("ШТкст");
		Значение::регистрируй<Комплекс>("Комплекс");
		Значение::регистрируй(VALUEARRAY_V, создайДанМассивЗач, "МассивЗнач");
		Значение::регистрируй(VALUEMAP_V, создайДанМапЗач, "МапЗнач");
		Значение::добавьИмя(STRING_V, "Ткст");
		Значение::добавьИмя(INT_V, "цел");
		Значение::добавьИмя(DOUBLE_V, "дво");
		Значение::добавьИмя(VOID_V, "проц");
		Значение::добавьИмя(DATE_V, "Дата");
		Значение::добавьИмя(TIME_V, "Время");
		Значение::добавьИмя(INT64_V, "дол");
		Значение::добавьИмя(BOOL_V, "бул");
		Значение::добавьИмя(ERROR_V, "Ошибка");
	};
}

проц ValueRegisterHelper()
{
	Значение::регистрируйСтд();
}

ИНИЦБЛОК {
	ValueRegisterHelper();
}

проц Значение::сериализуй(Поток& s) {
	регистрируйСтд();
	бцел тип;
	if(s.грузится()) {
		s / тип;
		if(тип >= 0x8000000)
			s.загрузиОш();
		освободи();
		цел st = тип == VOID_V ? VOIDV : тип == STRING_V ? STRING : тип;
		if(st == STRING)
			s % данные;
		else
		if(st >= 0 && st < 255 && svo[st]) {
			данные.устСпец((ббайт)тип);
			svo[st]->сериализуй(&данные, s);
		}
		else {
			typedef Проц* (*vp)();
			vp *cr = Typemap().найдиУк(тип);
			if(cr) {
				Проц *p = (**cr)();
				p->сериализуй(s);
				иницРеф(p, тип);
			}
			else {
				освободи();
				данные.устСпец(3);
				if(тип != VOID_V && тип != ERROR_V)
					s.загрузиОш();
			}
		}
	}
	else {
		тип = дайТип();
		ПРОВЕРЬ(тип < 0x8000000); // only Values with assigned real тип ИД can be serialized
		s / тип;
		цел st = данные.дайСпец();
		ПРОВЕРЬ_(!тип || тип == ERROR_V || тип == UNKNOWN_V || st == STRING ||
		        (реф_ли() ? Typemap().найди(тип) >= 0 : st < 255 && svo[st]),
		        дайИмя() + " не зарегистрировано для сериализации");
		if(st == VOIDV)
			return;
		if(st == STRING)
			s % данные;
		else
		if(реф_ли())
			укз()->сериализуй(s);
		else
			svo[st]->сериализуй(&данные, s);
	}
}

static Ткст s_binary("serialized_binary");

проц Значение::вРяр(РярВВ& xio)
{
	регистрируйСтд();
	if(xio.сохраняется()) {
		if(ошибка_ли()) {
			Значение v = Null;
			v.вРяр(xio);
			return;
		}
		бцел тип = дайТип();
		Ткст имя = дайИмя(тип);
		if(имя.дайСчёт() == 0) {
			xio.устАтр("тип", s_binary);
			Ткст s = гексТкст(сохраниКакТкст(*this));
			ДинрусРНЦП::вРяр(xio, s);
		}
		else {
			xio.устАтр("тип", имя);
			цел st = данные.дайСпец();
			ПРОВЕРЬ_(!тип || тип == ERROR_V || тип == UNKNOWN_V || st == STRING ||
			        (реф_ли() ? Typemap().найди(тип) >= 0 : st < 255 && svo[st]),
			        дайИмя() + " не зарегистрировано для xml-изации");
			if(st == VOIDV)
				return;
			if(st == STRING)
				ДинрусРНЦП::вРяр(xio, данные);
			else
			if(реф_ли())
				укз()->вРяр(xio);
			else
				svo[st]->вРяр(&данные, xio);
		}
	}
	else {
		Ткст имя = xio.дайАтр("тип");
		if(ДинрусРНЦП::пусто_ли(имя))
			*this = Значение();
		else
		if(имя == s_binary) {
			Ткст s;
			ДинрусРНЦП::вРяр(xio, s);
			try {
				грузиИзТкст(*this, сканГексТкст(s));
			}
			catch(LoadingError) {
				throw ОшибкаРяр("xmlize serialized_binary Ошибка");
			}
		}
		else {
			цел тип = дайТип(имя);
			if(ДинрусРНЦП::пусто_ли(тип))
				throw ОшибкаРяр("неверное значение типа");
			освободи();
			цел st = (бцел)тип == VOID_V ? VOIDV : (бцел)тип == STRING_V ? STRING : тип;
			if(st == STRING)
				ДинрусРНЦП::вРяр(xio, данные);
			else
			if(st < 255 && svo[st]) {
				данные.устСпец((ббайт)тип);
				svo[st]->вРяр(&данные, xio);
			}
			else {
				typedef Проц* (*vp)();
				vp *cr = Typemap().найдиУк(тип);
				if(cr) {
					Проц *p = (**cr)();
					p->вРяр(xio);
					иницРеф(p, тип);
				}
				else
					throw ОшибкаРяр("неверное значение типа");
			}
		}
	}
}

проц Значение::вДжейсон(ДжейсонВВ& jio)
{
	регистрируйСтд();
	if(jio.сохраняется()) {
		if(пусто_ли())
			jio.уст(Null);
		else {
			бцел тип = дайТип();
			Ткст имя = дайИмя(тип);
			if(имя.дайСчёт() == 0) {
				Ткст s = гексТкст(сохраниКакТкст(*this));
				jio("тип", s_binary)
				   ("значение", s);
			}
			else {
				цел st = данные.дайСпец();
				ПРОВЕРЬ_(!тип || тип == ERROR_V || тип == UNKNOWN_V || st == STRING ||
				        (реф_ли() ? Typemap().найди(тип) >= 0 : st < 255 && svo[st]),
				        дайИмя() + " не зарегистрировано для json-изации");
				if(st == VOIDV)
					return;
				ДжейсонВВ hio;
				if(st == STRING) {
					Ткст h = данные;
					ДинрусРНЦП::вДжейсон(hio, h);
				}
				else {
					if(реф_ли())
						укз()->вДжейсон(hio);
					else
						svo[st]->вДжейсон(&данные, hio);
				}
				МапЗнач m;
				m.добавь("тип", имя);
				m.добавь("значение", hio.дайРез());
				jio.уст(m);
			}
		}
	}
	else {
		Значение g = jio.дай();
		if(g.пусто_ли())
			*this = Null;
		else {
			Ткст имя = g["тип"];
			Значение  знач = g["значение"];
			if(имя == s_binary) {
				if(!ДинрусРНЦП::ткст_ли(знач))
					throw JsonizeError("serialized_binary Ошибка");
				Ткст s = знач;
				try {
					грузиИзТкст(*this, сканГексТкст(s));
				}
				catch(LoadingError) {
					throw JsonizeError("serialized_binary Ошибка");
				}
			}
			else {
				цел тип = дайТип(имя);
				if(ДинрусРНЦП::пусто_ли(тип))
					throw JsonizeError("invalid Значение тип");
				освободи();
				цел st = (бцел)тип == VOID_V ? VOIDV : (бцел)тип == STRING_V ? STRING : тип;
				if(st == STRING) {
					if(!ДинрусРНЦП::ткст_ли(знач))
						throw JsonizeError("serialized_binary Ошибка");
					данные = знач;
				}
				else {
					ДжейсонВВ hio(знач);
					if(st < 255 && svo[st]) {
						данные.устСпец((ббайт)тип);
						svo[st]->вДжейсон(&данные, hio);
					}
					else {
						typedef Проц* (*vp)();
						vp *cr = Typemap().найдиУк(тип);
						if(cr) {
							Проц *p = (**cr)();
							p->вДжейсон(hio);
							иницРеф(p, тип);
						}
						else
							throw JsonizeError("invalid Значение тип");
					}
				}
			}
		}
	}
}

проц Значение::регистрируй(бцел w, Проц* (*c)(), кткст0 имя) {
#ifdef flagCHECKINIT
	RLOG("регистрируй valuetype " << w);
#endif
	проверьНаОН(); // all needs to be registered at file level scope
	ПРОВЕРЬ(w != UNKNOWN_V);
	ПРОВЕРЬ(w < 0x8000000);
	CHECK(Typemap().дайДобавь(w, c) == c);
	добавьИмя(w, имя);
}

Ткст  Значение::вТкст() const {
	if(пусто_ли())
		return Null;
	if(ткст_ли())
		return данные;
	if(реф_ли())
		return укз()->какТкст();
	цел st = данные.дайСпец();
	return svo[st]->какТкст(&данные);
}

цел Значение::дайСчёт() const
{
	if(реф_ли()) {
		бцел t = дайРефТип();
		if(t == VALUEARRAY_V)
			return ((МассивЗнач::Данные *)укз())->данные.дайСчёт();
		if(t == VALUEMAP_V)
			return ((МапЗнач::Данные *)укз())->значение.дайСчёт();
	}
	return 0;
}

const Значение& Значение::operator[](цел i) const
{
	if(реф_ли()) {
		бцел t = дайРефТип();
		if(t == VALUEARRAY_V)
			return ((МассивЗнач::Данные *)укз())->данные[i];
		if(t == VALUEMAP_V)
			return ((МапЗнач::Данные *)укз())->значение[i];
	}
	return значОш();
}

const Вектор<Значение>& Значение::GetVA() const
{
	if(реф_ли()) {
		if(является<МассивЗнач>())
			return ((МассивЗнач::Данные *)укз())->данные;
		if(является<МапЗнач>())
			return ((МапЗнач::Данные *)укз())->значение.данные->данные;
	}
	return МассивЗнач::VoidData;
}

force_inline
Вектор<Значение>& Значение::разшарьArray()
{
	МассивЗнач::Данные *данные = (МассивЗнач::Данные *)укз();
	if(данные->GetRefCount() != 1) {
		МассивЗнач::Данные *d = new МассивЗнач::Данные;
		d->данные = клонируй(данные->данные);
		данные->отпусти();
		укз() = d;
		данные = d;
	}
	return данные->данные;
}

Значение& Значение::по(цел i)
{
	if(пусто_ли())
		*this = МассивЗнач();
	ПРОВЕРЬ(i >= 0 && реф_ли());
	бцел t = дайРефТип();
	if(t == VALUEMAP_V) {
		МассивЗнач& va = МапЗнач::разшарь((МапЗнач::Данные*&)укз()).значение;
		ПРОВЕРЬ(i < va.дайСчёт());
		return va.по(i);
	}
	ПРОВЕРЬ(t == VALUEARRAY_V);
	return разшарьArray().по(i);
}

проц Значение::добавь(const Значение& s)
{
	if(пусто_ли()) {
		if(реф_ли()) отпустиРеф();
		МассивЗнач::Данные *d = new МассивЗнач::Данные;
		d->данные.добавь(s);
		иницРеф(d, VALUEARRAY_V);
		Magic();
		return;
	}
	ПРОВЕРЬ(реф_ли() && дайРефТип() == VALUEARRAY_V);
	разшарьArray().добавь(s);
}

const Значение& Значение::operator[](const Ткст& ключ) const
{
	if(реф_ли() && дайРефТип() == VALUEMAP_V)
		return ((МапЗнач::Данные *)укз())->дай(ключ);
	return значОш();
}

Значение& Значение::дайДобавь(const Значение& ключ)
{
	if(пусто_ли()) {
		if(реф_ли()) отпустиРеф();
		МапЗнач::Данные *d = new МапЗнач::Данные;
		Значение& h = d->дайДобавь(ключ);
		иницРеф(d, VALUEMAP_V);
		Magic();
		return h;
	}
	if(дайТип() == VALUEARRAY_V) {
		МапЗнач m = *this;
		*this = m;
	}
	ПРОВЕРЬ(дайТип() == VALUEMAP_V);
	return МапЗнач::разшарь((МапЗнач::Данные*&)укз()).дайДобавь(ключ);
}

Значение& Значение::operator()(const Ткст& ключ)
{
	return дайДобавь(ключ);
}

Значение& Значение::operator()(кткст0 ключ)
{
	return дайДобавь(ключ);
}

Значение& Значение::operator()(const Ид& ключ)
{
	return дайДобавь(~ключ);
}

Ткст Значение::дайИмя() const
{
	if(реф_ли()) {
		Проц *p = укз(); // supress CLANG warning
		return typeid(*p).name();
	}
	if(ткст_ли())
		return "Ткст";
	static Кортеж<ббайт, const char *> tp[] = {
		{ (ббайт)INT_V, "цел" },
		{ (ббайт)DOUBLE_V, "дво" },
		{ (ббайт)VOIDV, "проц" },
		{ (ббайт)DATE_V, "Дата" },
		{ (ббайт)TIME_V, "Время" },
		{ (ббайт)INT64_V, "дол" },
		{ (ббайт)BOOL_V, "бул" },
	};
	Кортеж<ббайт, const char *> *x = найдиКортеж(tp, __countof(tp), данные.дайСпец());
	return x ? Ткст(x->b) : какТкст(дайТип());
}

class ValueErrorCls : public RichValueRep<Ткст> {
public:
	virtual бцел      дайТип() const             { return ERROR_V; }
	virtual бул       пусто_ли() const              { return true; }
	virtual проц       сериализуй(Поток& s)        {}
	virtual Ткст     какТкст() const            { return "<Ошибка: \'" + v + "\'>"; }

	ValueErrorCls(const Ткст& s) : RichValueRep<Ткст>(s)  {}
};

Значение значОш(const Ткст& s) {
	return Значение(new ValueErrorCls(s), ERROR_V);
}

Значение значОш(кткст0 s) {
	return значОш(Ткст(s));
}

const Значение& значОш() {
	static Значение v = значОш(Ткст());
	return v;
}

Ткст дайТекстОш(const Значение& v) {
	ПРОВЕРЬ(ошибка_ли(v));
	return ((RichValueRep<Ткст> *)v.дайПроцУк())->дай();
}

}
